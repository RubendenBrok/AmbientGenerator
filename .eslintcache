[{"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx":"1","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx":"2","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts":"3","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts":"4","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts":"5","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/visuals.ts":"6","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/chordcontainer.tsx":"7","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/loadingscreen.tsx":"8","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/mobileui.tsx":"9"},{"size":222,"mtime":1623276419000,"results":"10","hashOfConfig":"11"},{"size":30234,"mtime":1623511412000,"results":"12","hashOfConfig":"11"},{"size":1025,"mtime":1613054079000,"results":"13","hashOfConfig":"11"},{"size":6700,"mtime":1614793710000,"results":"14","hashOfConfig":"11"},{"size":21529,"mtime":1614793102000,"results":"15","hashOfConfig":"11"},{"size":10026,"mtime":1623507154000,"results":"16","hashOfConfig":"11"},{"size":2162,"mtime":1623276419000,"results":"17","hashOfConfig":"11"},{"size":1765,"mtime":1623276419000,"results":"18","hashOfConfig":"11"},{"size":7836,"mtime":1623505363000,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"asqc5z",{"filePath":"23","messages":"24","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"22"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"22"},"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx",[],["41","42"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx",["43","44","45","46","47","48"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/visuals.ts",["49"],"import * as PIXI from \"pixi.js\";\nimport { seqLength, keys } from \"./App\";\nimport { soundSources } from \"./soundsources\";\nimport { AdvancedBloomFilter, KawaseBlurFilter } from \"pixi-filters\";\nimport { mobile } from \"./App\";\n\nlet app: any;\nlet graph: any;\nlet overlay: any;\nlet fx: any;\n\nlet graphicsArr: any[] = [];\nlet bloomFilter: any;\nlet blurFilter: any;\n\nlet height: number;\nlet width: number;\nlet circleMaxR: number;\nlet circleMinR: number;\nlet circleMidX: number;\nlet circleMidY: number;\nlet ringDistance: number;\nlet dotSize: number;\n\nlet driftCircleMin = 2;\nconst driftCircleUnSelect = 2;\nconst driftCircleSelect = 8;\nconst driftCircleMax = 12;\nlet driftCircle = driftCircleMin;\nlet driftHover = false;\nlet driftButton: any;\nlet driftRippleCounter: number;\nlet driftRippleTime = 2000;\n\nconst trackWidthSelected = 9;\nconst trackWidthUnSelected = 2;\nlet objID = 0;\nconst PI = Math.PI;\nconst seqStepAngle = (2 * PI) / 32;\n\nexport const colors = [\n  0xff1239, 0xd61fff, 0x2a22ff, 0x26ffff, 0x28ff5e, 0xfffa5c, 0xffb950,\n  0xff6d33, 0xffbdc8,\n];\n\nlet amountOfDrawnTracks: number = 0;\n\nexport function initGraphics(mobileUI: boolean) {\n  // prevents crash on some Firefox versions (https://github.com/pixijs/pixi.js/issues/7070)\n  PIXI.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\n\n  //Create a Pixi Application\n  app = new PIXI.Application({\n    width: window.innerWidth,\n    height: window.innerHeight,\n    antialias: true,\n    transparent: true,\n    resolution: 1,\n  });\n\n  document.body.appendChild(app.view);\n\n  overlay = new PIXI.Graphics();\n  app.stage.addChild(overlay);\n  graph = new PIXI.Graphics();\n  app.stage.addChild(graph);\n\n  fx = new PIXI.Graphics();\n  app.stage.addChild(fx);\n\n  //initialize track data\n  soundSources.forEach((track: any, index: number) => {\n    if (track.kind === \"inst\" || track.kind === \"drum\") {\n      amountOfDrawnTracks++;\n    }\n  });\n  screenResize();\n\n  //initialize filters\n  bloomFilter = new AdvancedBloomFilter();\n  bloomFilter.threshold = 0.2;\n  bloomFilter.bloomScale = 1;\n  bloomFilter.blur = 3;\n  bloomFilter.quality = 4;\n  bloomFilter.brightness = 0.4;\n  graph.filters = [bloomFilter];\n\n  blurFilter = new KawaseBlurFilter();\n  blurFilter.blur = 2;\n  fx.filters = [blurFilter];\n\n  //initialize driftbutton\n  driftRippleCounter = performance.now();\n}\n\nclass rippleCircle {\n  x: number;\n  y: number;\n  size: number;\n  growth: number;\n  color: number;\n  creationTime: number;\n  lifeTime: number;\n  beginFade: number;\n  fadeTime: number;\n  id: number;\n  dead: boolean;\n  startOpacity: number;\n  opacity: number;\n  thickness: number;\n  r: number;\n\n  constructor(volume: number, track: number, seqIndex: number) {\n    this.r = circleMaxR - ringDistance * track;\n    this.x = circleMidX + this.r * Math.sin(-seqIndex * seqStepAngle + PI);\n    this.y = circleMidY + this.r * Math.cos(-seqIndex * seqStepAngle + PI);\n    this.size = (volume / 100) * dotSize;\n    this.color = colors[track];\n    this.thickness = 5 + 5 * (volume / 100);\n    this.creationTime = performance.now();\n    this.lifeTime = 500 + 600 * (volume / 100);\n    this.beginFade = 200;\n    this.fadeTime = this.lifeTime - this.beginFade;\n    this.id = objID;\n    objID++;\n    this.dead = false;\n    this.growth = 0.2 + volume / 300;\n    this.startOpacity = 0.4;\n    this.opacity = this.startOpacity;\n    this.update = this.update.bind(this);\n  }\n\n  update() {\n    let newState = updateFXCircle(this);\n    this.size = newState.size;\n    this.opacity = newState.opacity;\n    this.dead = newState.dead;\n  }\n\n  draw() {\n    // graph.beginFill(this.color, this.opacity);\n    drawFXCircle(\n      this.x,\n      this.y,\n      this.size,\n      this.thickness,\n      this.color,\n      this.opacity\n    );\n  }\n}\n\nclass driftRipple {\n  size: number;\n  growth: number;\n  color: number;\n  creationTime: number;\n  lifeTime: number;\n  beginFade: number;\n  fadeTime: number;\n  id: number;\n  dead: boolean;\n  startOpacity: number;\n  opacity: number;\n  thickness: number;\n\n  constructor() {\n    this.size = circleMaxR - ringDistance * amountOfDrawnTracks;\n    this.color = 0xffffff;\n    this.thickness = 15;\n    this.creationTime = performance.now();\n    this.lifeTime = 2000;\n    this.beginFade = 400;\n    this.fadeTime = this.lifeTime - this.beginFade;\n    this.id = objID;\n    objID++;\n    this.dead = false;\n    this.growth = 0.3;\n    this.startOpacity = 0.2;\n    this.opacity = this.startOpacity;\n    this.update = this.update.bind(this);\n  }\n\n  update() {\n    let newState = updateFXCircle(this);\n    this.size = newState.size;\n    this.opacity = newState.opacity;\n    this.dead = newState.dead;\n  }\n\n  draw() {\n    // graph.beginFill(this.color, this.opacity);\n    drawFXCircle(\n      width / 2,\n      height / 2,\n      this.size,\n      this.thickness,\n      this.color,\n      this.opacity\n    );\n  }\n}\n\nfunction drawFXCircle(\n  x: number,\n  y: number,\n  size: number,\n  thickness: number,\n  color: number,\n  opacity: number\n) {\n  fx.lineStyle(thickness, color, opacity);\n  fx.drawCircle(x, y, size);\n  fx.endFill();\n}\n\nfunction updateFXCircle(object: any) {\n  object.size += object.growth;\n\n  if (performance.now() > object.creationTime + object.beginFade) {\n    let howLongAmIFading =\n      performance.now() - object.creationTime - object.beginFade;\n    object.opacity =\n      object.startOpacity -\n      object.startOpacity * (howLongAmIFading / object.fadeTime);\n  }\n  if (performance.now() > object.creationTime + object.lifeTime) {\n    object.dead = true;\n  }\n  return object;\n}\n\nexport function updateGraphics(state: any) {\n  graph.clear();\n  fx.clear();\n  overlay.clear();\n\n  graph.beginFill(0x2a2a2a, 0.2);\n  graph.drawRect(0, 0, width, height);\n  graph.endFill();\n\n  graphicsArr.forEach((obj: any, index: number) => {\n    obj.update();\n    obj.draw();\n  });\n\n  for (let i = graphicsArr.length - 1; i >= 0; i--) {\n    if (graphicsArr[i].dead) {\n      graphicsArr.splice(i, 1);\n    }\n  }\n\n  // draw 8 white indicator lines\n  /*\n  overlay.lineStyle(1, 0x555555);\n  for (let i = 0; i < 8; i++) {\n    overlay.moveTo(\n      circleMidX +\n        (circleMaxR - ringDistance * amountOfDrawnTracks) *\n          Math.sin((i / 8) * (2 * PI)),\n      circleMidY +\n        (circleMaxR - ringDistance * amountOfDrawnTracks) *\n          Math.cos((i / 8) * (2 * PI))\n    );\n    overlay.lineTo(\n      circleMidX + circleMaxR * Math.sin((i / 8) * (2 * PI)),\n      circleMidY + circleMaxR * Math.cos((i / 8) * (2 * PI))\n    );\n  }\n  */\n\n  //draw the flow button circle\n  if (state.drifting) {\n    driftCircleMin = driftCircleSelect;\n  } else {\n    driftCircleMin = driftCircleUnSelect;\n  }\n\n  if (driftHover && driftCircle < driftCircleMax) {\n    driftCircle += 1;\n  }\n  if (!driftHover && driftCircle > driftCircleMin) {\n    driftCircle -= 1;\n  }\n  let r = circleMaxR - ringDistance * amountOfDrawnTracks;\n  fx.lineStyle(driftCircle, 0xffffff, 0.5);\n  fx.drawCircle(circleMidX, circleMidY, r);\n  overlay.lineStyle(2, 0xffffff, 0.5);\n  overlay.drawCircle(circleMidX, circleMidY, r);\n\n  //draw ripples if sequencer is drifting\n  if (state.drifting && state.playing) {\n    if (performance.now() - driftRippleCounter >= driftRippleTime) {\n      driftRippleCounter = performance.now();\n      graphicsArr.push(new driftRipple());\n    }\n  }\n\n  soundSources.forEach((track: any, index: number) => {\n    if (track.kind === \"drum\" || track.kind === \"inst\") {\n      if (!state[keys.disabledKey + index]) {\n        let r = circleMaxR - ringDistance * index;\n        let sixteenth = (60 / state.bpm / 4) * 1000;\n        let timeInCurrentStep = performance.now() - state.lastPlayTime;\n        let angle =\n          state.masterSeq.currentSequencePos * seqStepAngle +\n          (timeInCurrentStep / sixteenth) * seqStepAngle -\n          PI -\n          0.2;\n        let size = dotSize * (state[keys.volKey + index] / 100);\n\n        // draw a big circle in the color of the track\n        if (state.trackSelected[index]) {\n          fx.lineStyle(trackWidthSelected, colors[index], 0.5);\n        } else {\n          fx.lineStyle(trackWidthUnSelected, colors[index], 0.5);\n        }\n        fx.drawCircle(circleMidX, circleMidY, r);\n        overlay.lineStyle(2, colors[index], 0.5);\n        overlay.drawCircle(circleMidX, circleMidY, r);\n\n        //for each track, draw a circle when there is a sound in the sequencer\n        graph.beginFill(colors[index]);\n        for (let i = 0; i < seqLength; i++) {\n          if (!isNaN(state[keys.seqKey + index][i])) {\n            graph.drawCircle(\n              circleMidX + r * Math.sin(-i * seqStepAngle + PI),\n              circleMidY + r * Math.cos(-i * seqStepAngle + PI),\n              size\n            );\n          }\n        }\n        graph.endFill();\n\n        //draw the small circle to indicate where the sequencer is\n        if (state.playing) {\n          overlay.beginFill(0xcccccc);\n          overlay.drawCircle(\n            circleMidX + r * Math.sin(-angle),\n            circleMidY + r * Math.cos(-angle),\n            3\n          );\n          overlay.endFill();\n        }\n      }\n    }\n  });\n}\n\nexport function ripple(track: number, volume: number, seqIndex: number) {\n  graphicsArr.push(new rippleCircle(volume, track, seqIndex));\n}\n\nexport function screenResize() {\n  if (window.innerWidth < mobile) {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    app.renderer.resize(width, height);\n    circleMaxR = Math.min(height, width) / 2 - 20;\n    circleMinR = circleMaxR / 4;\n    circleMidX = width / 2;\n    circleMidY = height - width / 2 - (height / 1.8 - width);\n    ringDistance = (circleMaxR - circleMinR) / (amountOfDrawnTracks - 1);\n    dotSize = 10;\n  } else {\n    width = Math.max(window.innerWidth, 650);\n    height = Math.max(window.innerHeight, 550);\n    app.renderer.resize(width, height);\n    circleMaxR = Math.min(height, width * 0.6) / 2 - 50;\n    circleMinR = circleMaxR / 5;\n    circleMidX = width / 2;\n    circleMidY = height / 2;\n    ringDistance = (circleMaxR - circleMinR) / (amountOfDrawnTracks - 1);\n    dotSize = Math.min(width * 0.6, height) / 60;\n  }\n}\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/chordcontainer.tsx",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/loadingscreen.tsx",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/mobileui.tsx",["50","51","52"],"import {\n  keys,\n  amountOfSounds,\n  amountOfSoundsLoaded,\n  ControlledSlider,\n  IconContainer,\n  minBpm,\n  maxBpm,\n} from \"./App\";\nimport React, { useState } from \"react\";\nimport { soundSources } from \"./soundsources\";\nimport { colors } from \"./visuals\";\nimport LoadingScreen from \"./loadingscreen\";\n\nimport minus from \"./img/minus.svg\";\nimport plus from \"./img/plus.svg\";\nimport volumeOn from \"./img/volumeon.svg\";\nimport volumeOff from \"./img/volumeoff.svg\";\nimport play from \"./img/play.svg\";\nimport pause from \"./img/pause.svg\";\nimport turtle from \"./img/turtle.svg\";\nimport rabbit from \"./img/rabbit.svg\";\n\nimport \"./mobile.css\";\n\nexport const MobileUI = ({\n  state,\n  startApp,\n  handleTrackSelect,\n  handleVolumeChange,\n  handleActivityChange,\n  handlePatternChange,\n  handleDisableToggle,\n  handlePlayingToggle,\n  handleDriftToggle,\n  handleBpmChange,\n}: any) => {\n  const [trackOpen, setTrackOpen] = useState(false);\n\n  const [openIndex, setOpenIndex] = useState(0);\n\n  let playIcon: string;\n  state.playing ? (playIcon = pause) : (playIcon = play);\n\n  const handleTrackClick = (index: number, open: boolean) => {\n    setTrackOpen(open);\n    setOpenIndex(index);\n    handleTrackSelect(index, open);\n  };\n\n  return (\n    <div className=\"mobileUIContainer\">\n      <LoadingScreen\n        loaded={state.loaded}\n        started={state.appStarted}\n        hideOpeningScreen={state.hideOpeningScreen}\n        startApp={startApp}\n        loadingAnimPoints={state.loadingAnimPoints}\n        totalSounds={amountOfSounds}\n        loadedSounds={amountOfSoundsLoaded}\n      />\n      {!trackOpen && (\n        <div className=\"mobileUIContainerBase\">\n          <div className=\"mobileTrackContainer\">\n            {soundSources.map((track: any, index: number) => {\n              if (track.kind === \"drum\" || track.kind === \"inst\") {\n                return (\n                  <MobileTrackButton\n                    handleTrackClick={handleTrackClick}\n                    key={index}\n                    index={index}\n                    nowPlaying={false}\n                    disabled={state[keys.disabledKey + index]}\n                  />\n                );\n              }\n            })}\n          </div>\n          <div className={\"mobileButtonContainer\"}>\n            <div\n              className=\"mobileButton\"\n              onClick={handlePlayingToggle}\n              style={{ backgroundImage: \"url('\" + playIcon + \"')\" }}\n            ></div>\n            <div className=\"mobileButton \">\n              <div className=\"mobileHelp\">?</div>\n            </div>\n            <div className=\"mobileButton \" onClick={handleDriftToggle}>\n              <div className=\"mobileHelp\" style={{ fontSize: \"1rem\" }}>\n                {state.drifting ? \"EVOLVING\" : \"EVOLVE\"}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n      {trackOpen && (\n        <MobileTrackEditor\n          state={state}\n          openIndex={openIndex}\n          handleTrackClick={handleTrackClick}\n          handleVolumeChange={handleVolumeChange}\n          handlePatternChange={handlePatternChange}\n          handleActivityChange={handleActivityChange}\n          handleDisableToggle={handleDisableToggle}\n        />\n      )}\n      <div className=\"mobileUIContainerBottom\">\n        <div className=\"trackSlider\">\n          <img className=\"speedIcon\" src={turtle} />\n          <ControlledSlider\n            vertical={false}\n            index={0}\n            value={state.bpm}\n            onChange={handleBpmChange}\n            min={minBpm}\n            max={maxBpm}\n          />\n          <img className=\"speedIcon\" src={rabbit} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nconst MobileTrackButton = ({\n  handleTrackClick,\n  index,\n  nowPlaying,\n  disabled,\n}: any) => {\n  let colorStr = colors[index].toString(16);\n  colorStr = \"#\".concat(colorStr);\n\n  let shadow: string;\n  nowPlaying\n    ? (shadow = `0px 0px 15px #${colors[index].toString(16)}`)\n    : (shadow = `0px 0px 5px #${colors[index].toString(16)}`);\n\n  let indicatorClass = \"mobileTrackIndicator\";\n\n  if (disabled) {\n    indicatorClass += \" disabled\";\n  }\n\n  return (\n    <div className=\"mobileTrack\">\n      <div\n        className={indicatorClass}\n        style={{\n          backgroundColor: colorStr,\n          boxShadow: shadow,\n        }}\n        onClick={() => handleTrackClick(index, true)}\n      ></div>\n    </div>\n  );\n};\n\nconst MobileTrackEditor = ({\n  openIndex,\n  nowPlaying,\n  state,\n  handleTrackClick,\n  handleVolumeChange,\n  handleActivityChange,\n  handlePatternChange,\n  handleDisableToggle,\n}: any) => {\n  let colorStr = colors[openIndex].toString(16);\n  colorStr = \"#\".concat(colorStr);\n\n  let shadow: string;\n  nowPlaying\n    ? (shadow = `0px 0px 15px #${colors[openIndex].toString(16)}`)\n    : (shadow = `0px 0px 5px #${colors[openIndex].toString(16)}`);\n\n  let indicatorClass = \"mobileTrackIndicator single\";\n\n  if (state[keys.disabledKey + openIndex]) {\n    indicatorClass += \" disabled\";\n  }\n\n  return (\n    <div className=\"mobileTrackEditor\">\n      <div className=\"mobileTrackEditorTop\">\n        <div className=\"mobileTrackIndicatorEditor\">\n          <div\n            className={indicatorClass}\n            style={{\n              backgroundColor: colorStr,\n              boxShadow: shadow,\n            }}\n            onClick={() =>\n              handleDisableToggle(\n                state[keys.disabledKey + openIndex],\n                openIndex\n              )\n            }\n          ></div>\n        </div>\n        <div className=\"trackUI\">\n          <div className=\"trackSliderContainer\">\n            <div className=\"trackSlider\">\n              <IconContainer icon1={volumeOff} />\n              <ControlledSlider\n                value={state[keys.volKey + openIndex]}\n                onChange={handleVolumeChange}\n                disabled={state[keys.disabledKey + openIndex]}\n                index={openIndex}\n                min={0}\n                max={100}\n                step={1}\n              />\n              <IconContainer icon1={volumeOn} />\n            </div>\n            {soundSources[openIndex].kind === \"inst\" ? (\n              <div className=\"trackSlider\">\n                <IconContainer icon1={minus} />\n                <ControlledSlider\n                  value={state[keys.actKey + openIndex]}\n                  onChange={handleActivityChange}\n                  disabled={state[keys.disabledKey + openIndex]}\n                  index={openIndex}\n                  min={0}\n                  max={100}\n                  step={1}\n                />\n                <IconContainer icon1={plus} />\n              </div>\n            ) : (\n              <div className=\"trackSlider\">\n                <IconContainer icon1={minus} />\n                <ControlledSlider\n                  value={state[keys.patKey + openIndex]}\n                  onChange={handlePatternChange}\n                  disabled={state[keys.disabledKey + openIndex]}\n                  index={openIndex}\n                  min={1}\n                  max={soundSources[openIndex].patterns.length}\n                  step={1}\n                />\n                <IconContainer icon1={plus} />\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n      <div className=\"mobileEditorButtonContainer\">\n        <div\n          className=\"mobileEditorButton\"\n          onClick={() =>\n            handleDisableToggle(state[keys.disabledKey + openIndex], openIndex)\n          }\n        >\n          <u className={state[keys.disabledKey + openIndex] ? \"flash\" : \"\"}>\n            {state[keys.disabledKey + openIndex] ? \"TURN ON\" : \"TURN OFF\"}\n          </u>\n        </div>\n        <div\n          className=\"mobileEditorButton\"\n          onClick={() => handleTrackClick(openIndex, false)}\n        >\n          <u>CLOSE</u>\n        </div>\n      </div>\n    </div>\n  );\n};\n",{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","replacedBy":"56"},{"ruleId":"57","severity":1,"message":"58","line":587,"column":53,"nodeType":"59","messageId":"60","endLine":587,"endColumn":55},{"ruleId":"57","severity":1,"message":"58","line":708,"column":53,"nodeType":"59","messageId":"60","endLine":708,"endColumn":55},{"ruleId":"61","severity":1,"message":"62","line":741,"column":9,"nodeType":"63","endLine":741,"endColumn":51},{"ruleId":"61","severity":1,"message":"62","line":750,"column":9,"nodeType":"63","endLine":750,"endColumn":51},{"ruleId":"57","severity":1,"message":"58","line":786,"column":57,"nodeType":"59","messageId":"60","endLine":786,"endColumn":59},{"ruleId":"61","severity":1,"message":"62","line":836,"column":7,"nodeType":"63","endLine":836,"endColumn":47},{"ruleId":"64","severity":1,"message":"65","line":31,"column":5,"nodeType":"66","messageId":"67","endLine":31,"endColumn":21},{"ruleId":"57","severity":1,"message":"58","line":65,"column":59,"nodeType":"59","messageId":"60","endLine":65,"endColumn":61},{"ruleId":"61","severity":1,"message":"62","line":109,"column":11,"nodeType":"63","endLine":109,"endColumn":53},{"ruleId":"61","severity":1,"message":"62","line":118,"column":11,"nodeType":"63","endLine":118,"endColumn":53},"no-native-reassign",["68"],"no-negated-in-lhs",["69"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","@typescript-eslint/no-unused-vars","'driftButton' is defined but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]