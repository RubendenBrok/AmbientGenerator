[{"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx":"1","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts":"2","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx":"3","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts":"4","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts":"5","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts":"6","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/visuals.ts":"7"},{"size":502,"mtime":1612961605000,"results":"8","hashOfConfig":"9"},{"size":425,"mtime":1611927196000,"results":"10","hashOfConfig":"9"},{"size":30139,"mtime":1614781886000,"results":"11","hashOfConfig":"9"},{"size":1025,"mtime":1613054079000,"results":"12","hashOfConfig":"9"},{"size":6870,"mtime":1614781323000,"results":"13","hashOfConfig":"9"},{"size":21527,"mtime":1614781671000,"results":"14","hashOfConfig":"9"},{"size":10147,"mtime":1614602646000,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"asqc5z",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"18"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"18"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx",[],["34","35"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx",["36","37","38","39","40","41","42"],"import React from \"react\";\nimport { updateDrift } from \"./drift\";\nimport {\n  initSoundPlayer,\n  setTrackVolume,\n  updateSeqChords,\n  playFX,\n  stopAllSounds,\n  randomMutation,\n  buildFromActivity,\n  buildFromPattern,\n  updateActivity\n} from \"./soundplayer\";\nimport { soundSources } from \"./soundsources\";\nimport \"./App.css\";\nimport { updateGraphics, initGraphics, ripple, colors } from \"./visuals\";\nimport minus from \"./img/minus.svg\"\nimport plus from \"./img/plus.svg\"\nimport volumeOn from \"./img/volumeon.svg\"\nimport volumeOff from \"./img/volumeoff.svg\"\nimport turtle from \"./img/turtle.svg\"\nimport rabbit from \"./img/rabbit.svg\"\nimport rain from \"./img/rain.svg\"\nimport trees from \"./img/trees.svg\"\nimport gramophone from \"./img/gramophone.svg\"\nimport play from \"./img/play.svg\"\nimport pause from \"./img/pause.svg\"\n\n// keys for dymaically creating and accessing state properties\nexport const keys = { \nvolKey : \"volume\",\nactKey : \"activity\",\nvolDriftKey : \"volDriftVelocity\",\nactDriftKey : \"actDriftVelocity\",\ndisabledKey : \"disabled\",\npatKey : \"pattern\",\nseqKey : \"currentSequence\",\nshowTrack : \"showTrack\",\nnowPlaying : \"nowPlaying\"\n}\nexport const seqLength = 32;\nconst chords = [{\n  value: \"G\",\n  name: \"G\"\n},{\n  value: \"A\",\n  name: \"Am\"\n},{\n  value: \"B\",\n  name: \"Bm\"\n},{\n  value: \"C\",\n  name: \"C\"\n},{\n  value: \"D\",\n  name: \"D\"\n},{\n  value: \"E\",\n  name: \"Em\"\n}],\nchordChangeOptions = [2,4,8],\ndrumChangeOptions = [2,4,8,16],\ntempoChangeOptions = [8,16],\nFXLength = 6000,\nmaxBpm = 150,\nminBpm = 50,\nbpmVariance = 8,\nfxIcons = [gramophone, rain, trees];\n\n\n// initialize state from soundsources object, create properties for every track\nconst initState: any = {};\ninitializeState();\n\nexport class App extends React.Component<any, any> {\n  constructor(props: any) {\n    super(props);\n    this.state = { ...initState };\n\n    this.appLoop = this.appLoop.bind(this);\n    this.updateMasterSeq = this.updateMasterSeq.bind(this);\n    this.handleVolumeChange = this.handleVolumeChange.bind(this);\n    this.handleActivityChange = this.handleActivityChange.bind(this);\n    this.handleDriftToggle = this.handleDriftToggle.bind(this);\n    this.handleDisableToggle = this.handleDisableToggle.bind(this);\n    this.handleChordUIToggle = this.handleChordUIToggle.bind(this);\n    this.handleFxUIToggle = this.handleFxUIToggle.bind(this);\n    this.handlePatternChange = this.handlePatternChange.bind(this);\n    this.handleBpmChange = this.handleBpmChange.bind(this);\n    this.handleChordClick = this.handleChordClick.bind(this);\n    this.handleChordChange = this.handleChordChange.bind(this);\n    this.handlePlayingToggle = this.handlePlayingToggle.bind(this);\n    this.startApp = this.startApp.bind(this);\n    this.animateLoadingScreen = this.animateLoadingScreen.bind(this);\n  }\n\n  startApp() {\n    this.setState({ appStarted: true }, () => {\n      let sixteenth = (60 / this.state.bpm / 4) * 1000;\n      setTimeout(this.updateMasterSeq, sixteenth);\n      setTimeout(this.appLoop, 100);\n      setTimeout(() => this.setState({hideOpeningScreen : true}), 500)\n    });\n  }\n\n  animateLoadingScreen() {\n    if (!this.state.loaded){\n      let newPoints = [...this.state.loadingAnimPoints];\n      newPoints.push(\".\");\n      if (newPoints.length > 4) {newPoints.length = 0;}\n      this.setState({loadingAnimPoints : newPoints})\n      setTimeout(this.animateLoadingScreen, 500)\n    }\n  }\n\n  handleVolumeChange(value: any, index: number) {\n    let newVolumeState: any = {};\n    newVolumeState[keys.volKey + index] = parseFloat(value);\n    this.setState({ ...newVolumeState }, () =>\n      setTrackVolume(this.state[keys.volKey + index], index)\n    );\n  }\n\n  handleActivityChange(value: any, index: number) {\n    let newActivityState: any = {};\n    newActivityState[keys.actKey + index] = parseFloat(value);\n    this.setState({ ...newActivityState }, () => {\n      let newSeqState: any = {};\n      newSeqState[keys.seqKey + index] = updateActivity(\n        this.state.currentChord,\n        soundSources[index].sounds,\n        this.state[keys.actKey + index],\n        soundSources[index].minSoundsInSequence,\n        soundSources[index].maxSoundsInSequence,\n        this.state[keys.seqKey + index]\n      );\n      this.setState({ ...newSeqState });\n    });\n  }\n\n  handleDriftToggle() {\n    let newDriftState: any = {};\n    newDriftState.drifting = !this.state.drifting;\n    newDriftState.masterSeq = this.state.masterSeq;\n    newDriftState.masterSeq.newDrumSeq =\n      this.state.masterSeq.newDrumSeq + randomArrEntry(drumChangeOptions);\n    this.setState({ ...newDriftState });\n  }\n\n  handleDisableToggle(value: boolean, index: number) {\n    let newDisabledState: any = {};\n    newDisabledState[keys.disabledKey + index] = !value;\n    if (!value) {\n      stopAllSounds(index);\n    }\n    this.setState({ ...newDisabledState });\n  }\n\n  handleChordUIToggle() {\n    let newUIState: any = {};\n    newUIState.showChordUI = !this.state.showChordUI;\n    this.setState({ ...newUIState });\n  }\n\n  handleFxUIToggle() {\n    let newUIState: any = {};\n    newUIState.showFxUI = !this.state.showFxUI;\n    this.setState({ ...newUIState });\n  }\n\n  handleChordClick(index: number) {\n    let newSeq = this.state.masterSeq;\n    newSeq.progression[index] = newSeq.progression[index] + 1;\n    if (newSeq.progression[index] >= chords.length) {\n      newSeq.progression[index] = 0;\n    }\n    if (newSeq.currentBarInProgression === index) {\n      this.handleChordChange(chords[newSeq.progression[index]].value);\n    }\n  }\n\n  handleChordChange(chord: string) {\n    if (chord !== this.state.currentChord) {\n      this.setState({ currentChord: chord }, () => {\n        soundSources.forEach((track: any, index: any) => {\n          if (track.kind === \"inst\") {\n            let newSeqState: any = {};\n            newSeqState[keys.seqKey + index] = updateSeqChords(\n              this.state.currentChord,\n              soundSources[index].sounds,\n              this.state[keys.seqKey + index]\n            );\n            this.setState({ ...newSeqState });\n          }\n        });\n      });\n    }\n  }\n\n  handleBpmChange(newBpm: number) {\n    this.setState({ bpm: newBpm });\n  }\n\n  handlePlayingToggle() {\n    this.setState({ playing: !this.state.playing }, () => {\n      if (!this.state.playing) {\n        soundSources.forEach((track: any, index: number) => {\n          stopAllSounds(index);\n        });\n      }\n    });\n  }\n\n  handlePatternChange(value: number, index: number) {\n    let newPatternState: any = {};\n    newPatternState[keys.patKey + index] = value;\n    this.setState({ ...newPatternState }, () => {\n      let newSeq: any = {};\n      newSeq[keys.seqKey + index] = buildFromPattern(\n        value - 1,\n        soundSources[index].patterns,\n        soundSources[index].sounds\n      );\n      this.setState({ ...newSeq });\n    });\n  }\n\n  updateMasterSeq() {\n    this.setState({ lastPlayTime: performance.now() });\n    let sixteenth = (60 / this.state.bpm / 4) * 1000;\n    setTimeout(this.updateMasterSeq, sixteenth);\n\n    if (this.state.playing) {\n      if (this.state.drifting) {\n        //check if track properties should 'drift'\n        soundSources.forEach((track: any, index: number) => {\n          let newVolDriftVelocity: any = {};\n          let newActDriftVelocity: any = {};\n          let newVolumeObj = updateDrift(\n            this.state[keys.volKey + index],\n            this.state[keys.volDriftKey + index],\n            100,\n            0\n          );\n          newVolDriftVelocity[keys.volDriftKey + index] = newVolumeObj.velocity;\n          this.setState({ ...newVolDriftVelocity });\n          this.handleVolumeChange(newVolumeObj.value, index);\n\n          if (track.kind === \"inst\") {\n            let newActivityObj = updateDrift(\n              this.state[keys.actKey + index],\n              this.state[keys.actDriftKey + index],\n              100,\n              0\n            );\n            newActDriftVelocity[keys.actDriftKey + index] =\n              newActivityObj.velocity;\n            this.setState({ ...newActDriftVelocity });\n            this.handleActivityChange(newActivityObj.value, index);\n          }\n        });\n      }\n\n      let newSeqState = { ...this.state.masterSeq };\n\n      // play sounds\n      let whosPlaying = playSequencers(this.state);\n      this.setState({ ...whosPlaying });\n      newSeqState.currentSequencePos++;\n      if (newSeqState.currentSequencePos >= seqLength) {\n        newSeqState.currentSequencePos = 0;\n        newSeqState.barsPlayed++;\n\n        //handle cycling through the chord progression\n        newSeqState.currentBarInProgression++;\n        if (newSeqState.currentBarInProgression > 3) {\n          newSeqState.currentBarInProgression = 0;\n        }\n        if (\n          chords[newSeqState.progression[newSeqState.currentBarInProgression]]\n            .value !== this.state.currentChord\n        ) {\n          this.handleChordChange(\n            chords[newSeqState.progression[newSeqState.currentBarInProgression]]\n              .value\n          );\n        }\n\n        //should the tempo randomly change?\n        if (this.state.drifting) {\n          if (newSeqState.barsPlayed >= newSeqState.tempoChangeTimer) {\n            newSeqState.tempoChangeTimer =\n              newSeqState.barsPlayed + randomArrEntry(tempoChangeOptions);\n            let newBpm = this.state.bpm;\n            newBpm -= bpmVariance;\n            newBpm += Math.round(bpmVariance * 2 * Math.random());\n            if (newBpm > maxBpm) {\n              newBpm = maxBpm;\n            }\n            if (newBpm < minBpm) {\n              newBpm = minBpm;\n            }\n            this.handleBpmChange(newBpm);\n          }\n\n          // should a sequence mutate/evolve?\n          soundSources.forEach((track: any, index: number) => {\n            if (!this.state[keys.disabledKey + index]) {\n              if (track.kind === \"inst\") {\n                if (Math.random() < track.mutationChance) {\n                  let newSeq: any = {};\n                  newSeq[keys.seqKey + index] = randomMutation(\n                    1,\n                    this.state[keys.seqKey + index],\n                    soundSources[index].sounds,\n                    true,\n                    this.state.currentChord\n                  );\n                  this.setState({ ...newSeq });\n                }\n              }\n              if (track.kind === \"drum\") {\n                if (Math.random() < track.mutationChance) {\n                  let newSeq: any = {};\n                  newSeq[keys.seqKey + index] = randomMutation(\n                    1,\n                    this.state[keys.seqKey + index],\n                    soundSources[index].sounds,\n                    false,\n                    this.state.currentChord\n                  );\n                  this.setState({ ...newSeq });\n                }\n              }\n            }\n          });\n\n          // should the drums change to a new pattern?\n          if (newSeqState.barsPlayed >= newSeqState.newDrumSeq) {\n            soundSources.forEach((track: any, index: number) => {\n              if (track.kind === \"drum\") {\n                this.handlePatternChange(\n                  Math.floor(Math.random() * track.patterns.length) + 1,\n                  index\n                );\n              }\n            });\n            newSeqState.newDrumSeq =\n              randomArrEntry(drumChangeOptions) + newSeqState.barsPlayed;\n          }\n\n          //should the chords randomly change?\n          if (newSeqState.barsPlayed >= newSeqState.newChord) {\n            let changeIndex = Math.floor(\n              Math.random() * newSeqState.progression.length\n            );\n            newSeqState.progression[changeIndex] = Math.floor(\n              Math.random() * chords.length\n            );\n            newSeqState.newChord =\n              randomArrEntry(chordChangeOptions) + newSeqState.barsPlayed;\n            if (newSeqState.barsPlayed % 4 === changeIndex) {\n              this.handleChordChange(\n                chords[newSeqState.progression[changeIndex]].value\n              );\n            }\n          }\n        }\n      }\n\n      //retrigger FX loops if necessary\n      if (performance.now() - newSeqState.FXTimer > FXLength) {\n        playFX(this.state);\n        newSeqState.FXTimer = performance.now();\n      }\n\n      this.setState({ masterSeq: newSeqState });\n    }\n  }\n\n  // main loop\n  appLoop() {\n    updateGraphics(this.state);\n    window.requestAnimationFrame(this.appLoop);\n  }\n\n  componentDidMount() {\n    this.animateLoadingScreen();\n    initSoundPlayer(this.state);\n    initGraphics();\n\n    soundSources.forEach((sound: any, index: number) => {\n      if (sound.kind === \"inst\") {\n        let newSeq: any = {};\n        newSeq[keys.seqKey + index] = buildFromActivity(\n          initState.currentChord,\n          soundSources[index].sounds,\n          soundSources[index].initActivity,\n          soundSources[index].minSoundsInSequence,\n          soundSources[index].maxSoundsInSequence\n        );\n        this.setState({ ...newSeq });\n      }\n      if (sound.kind === \"drum\") {\n        let newSeq: any = {};\n        newSeq[keys.seqKey + index] = buildFromPattern(\n          soundSources[index].initPattern,\n          soundSources[index].patterns,\n          soundSources[index].sounds\n        );\n        this.setState({ ...newSeq });\n      }\n    });\n\n    \n    window.addEventListener(\"load\", () => {\n      this.setState({ loaded: true });\n    });\n    \n   //setTimeout(()=>this.setState({ loaded: true }), 1000)\n  }\n\n  render() {\n    return (\n          <div className=\"UIContainer\">\n            <LoadingScreen\n            loaded={this.state.loaded}\n            started={this.state.appStarted}\n            hideOpeningScreen={this.state.hideOpeningScreen}\n            startApp={this.startApp}\n            loadingAnimPoints={this.state.loadingAnimPoints}\n            />\n            <FlowButton\n              drifting={this.state.drifting}\n              handleDriftToggle={this.handleDriftToggle}\n            />\n            <div className=\"UILeft\">\n              <InstContainer\n                state={this.state}\n                handleVolumeChange={this.handleVolumeChange}\n                handleActivityChange={this.handleActivityChange}\n                handleDisableToggle={this.handleDisableToggle}\n                handlePatternChange={this.handlePatternChange}\n              />\n              <ChordContainer\n                currentChord={this.state.currentChord}\n                currentBarInProgression={\n                  this.state.masterSeq.currentBarInProgression\n                }\n                progression={this.state.masterSeq.progression}\n                handleChordClick={this.handleChordClick}\n                showUI={this.state.showChordUI}\n                handleChordUIToggle={this.handleChordUIToggle}\n              />\n            </div>\n            <div className=\"UIRight\">\n              <DrumContainer\n                tracks={this.state}\n                handleVolumeChange={this.handleVolumeChange}\n                handlePatternChange={this.handlePatternChange}\n                handleDisableToggle={this.handleDisableToggle}\n                showUI={this.state.showDrumUI}\n              />\n              <FXContainer\n                UIIndex={2}\n                tracks={this.state}\n                handleVolumeChange={this.handleVolumeChange}\n                handleFxUIToggle={this.handleFxUIToggle}\n                showUI={this.state.showFxUI}\n              />\n              <PlayContainer\n                bpm={this.state.bpm}\n                playing={this.state.playing}\n                handleBpmChange={this.handleBpmChange}\n                handlePlayingToggle={this.handlePlayingToggle}\n              />\n            </div>\n          </div>\n\n    );\n  }\n} \n\nconst LoadingScreen = React.memo(function LoadingScreen(props: any) {\n  let opacityClass: string;\n  let displayStr: string;\n  if (props.hideOpeningScreen) {\n    displayStr = \"none\";\n  } else {\n    displayStr = \"block\";\n  }\n  if (props.started) {\n    opacityClass = \"hide\";\n  } else {\n    opacityClass = \"show\";\n  }\n  return (\n    <div\n      className={\"loadingContainer \" + opacityClass}\n      style={{ display: displayStr }}\n    >\n      <div className=\"quoteContainer\">\n        <div className=\"quote\" id=\"quote1\">\n          <div>\n            <h2>\n              <i>noun: </i>\n              <b>flow</b>\n            </h2>\n          </div>\n          <ul>\n            <li>\n              the action or fact of moving along in a steady, continuous stream.\n            </li>\n            <li>a steady, continuous stream or supply of something.</li>\n            <li>\n              the gradual permanent deformation of a solid under stress, without\n              melting.\n            </li>\n          </ul>\n        </div>\n\n        <div className=\"quote\" id=\"quote2\">\n          “The only way to make sense out of change is to plunge into it, move\n          with it, and join the dance.”\n          <br />\n          <i>― Alan Wilson Watts</i>\n        </div>\n      </div>\n      {props.loaded ? (\n        <div className=\"startButton\" onClick={props.startApp}>\n          Start\n          <div className=\"hoverLine\"></div>\n        </div>\n      ) : (\n        <div className=\"loadingBox\">\n          {\"Loading\" + props.loadingAnimPoints.join(\"\")}\n        </div>\n      )}\n    </div>\n  );\n});\n\nconst InstContainer = React.memo(function InstrumentContainer(props: any) {\n  return (\n    <div className=\"instrumentContainer\">\n      {soundSources.map((track: any, index: number) => {\n        if (track.kind === \"inst\")\n          return (\n            <TrackContainer\n              index={index}\n              key={index}\n              volume={props.state[keys.volKey + index]}\n              range2Value={props.state[keys.actKey + index]}\n              disabled={props.state[keys.disabledKey + index]}\n              range2Min={0}\n              range2Max={100}\n              range2Step={1}\n              kind={track.kind}\n              showTrack={props.state[keys.showTrack + index]}\n              nowPlaying={props.state[keys.nowPlaying + index]}\n              handleVolumeChange={props.handleVolumeChange}\n              handleActivityChange={props.handleActivityChange}\n              handlePatternChange={props.handlePatternChange}\n              handleDisableToggle={props.handleDisableToggle}\n            />\n          );\n      })}\n    </div>\n  );\n})\n\nconst TrackContainer = React.memo(function TrackUI(props: any) {\n  let colorStr = colors[props.index].toString(16);\n  colorStr = \"#\".concat(colorStr);\n\n  let indicatorClass = \"trackIndicator\";\n  let flexDirection: any;\n\n  if (props.kind === \"inst\") {\n    indicatorClass += \" inst\";\n    flexDirection = \"row\";\n  } else {\n    indicatorClass += \" drum\";\n    flexDirection = \"row-reverse\";\n  }\n  let disabled: string;\n  let shadow: string;\n  props.disabled ? (disabled = \"disabled\") : (disabled = \"\");\n  props.nowPlaying\n    ? (shadow = `0px 0px 15px #${colors[props.index].toString(16)}`)\n    : (shadow = `0px 0px 5px #${colors[props.index].toString(16)}`);\n  if (props.disabled) {\n    indicatorClass += \" disabled\";\n  }\n  return (\n    <div className=\"trackContainer\" style={{ flexDirection: flexDirection }} id={\"track\"+props.index}>\n      <div\n        className={indicatorClass}\n        style={{\n          backgroundColor: colorStr,\n          boxShadow: shadow,\n        }}\n        onClick={() => props.handleDisableToggle(props.disabled, props.index)}\n      ></div>\n      {!props.disabled ? (\n        <div className=\"trackUI\">\n          <div className=\"trackSliderContainer\">\n            <div className = \"trackSlider\">\n              <IconContainer icon1={volumeOff} />\n              <ControlledSlider\n                value={props.volume}\n                onChange={props.handleVolumeChange}\n                disabled={props.disabled}\n                index={props.index}\n                min={0}\n                max={100}\n                step={1}\n              />\n              <IconContainer icon1={volumeOn} />\n            </div>\n            {props.kind === \"inst\" ? (\n              <div  className = \"trackSlider\">\n                <IconContainer icon1={minus} />\n                <ControlledSlider\n                  value={props.range2Value}\n                  onChange={props.handleActivityChange}\n                  disabled={props.disabled}\n                  index={props.index}\n                  min={props.range2Min}\n                  max={props.range2Max}\n                  step={props.range2Step}\n                />\n                <IconContainer icon1={plus} />\n              </div>\n            ) : (\n              <div  className = \"trackSlider\">\n                <IconContainer icon1={minus} />\n                <ControlledSlider\n                  value={props.range2Value}\n                  onChange={props.handlePatternChange}\n                  disabled={props.disabled}\n                  index={props.index}\n                  min={1}\n                  max={soundSources[props.index].patterns.length}\n                  step={props.range2Step}\n                />\n                <IconContainer icon1={plus} />\n              </div>\n            )}\n          </div>\n        </div>\n      ) : (\n        \"\"\n      )}\n    </div>\n  );\n});\n\nconst DrumContainer = React.memo(function DrumContainer(props: any) {\n  return (\n      <div className=\"drumContainer\">\n        {soundSources.map((track: any, index: number) => {\n          if (track.kind === \"drum\")\n            return (\n              <TrackContainer\n                index={index}\n                key={index}\n                volume={props.tracks[keys.volKey + index]}\n                range2Value={props.tracks[keys.patKey + index]}\n                disabled={props.tracks[keys.disabledKey + index]}\n                range2Min={0}\n                range2Max={100}\n                range2Step={1}\n                kind={track.kind}\n                showTrack={props.tracks[keys.showTrack + index]}\n                nowPlaying={props.tracks[keys.nowPlaying + index]}\n                handleVolumeChange={props.handleVolumeChange}\n                handleActivityChange={props.handleActivityChange}\n                handlePatternChange={props.handlePatternChange}\n                handleDisableToggle={props.handleDisableToggle}\n              />\n            );\n        })}    \n      </div>\n  );\n});\n\nconst PlayContainer = React.memo(function PlayContainer(props: any) {\n  let playIcon : string;\n  props.playing ? playIcon = pause : playIcon = play;\n  return (\n    <div className=\"playContainer\">\n\n      <div className=\"bpmslider\">\n        <img className=\"speedIcon\" src={turtle} />\n        <ControlledSlider\n          vertical={true}\n          index={0}\n          value={props.bpm}\n          onChange={props.handleBpmChange}\n          min={minBpm}\n          max={maxBpm}\n        />\n        <img className=\"speedIcon\" src={rabbit} />\n      </div>\n      <div className = {\"buttonContainer\"}>\n      <div className=\"button\" onClick={props.handlePlayingToggle}\n      style = {{backgroundImage: \"url(\"+playIcon+\")\"}}>\n      </div>\n      </div>\n    </div>\n  );\n});\n\nconst FlowButton = React.memo(function FlowButton(props:any){\n  let selectClass = \"\";\n  if (props.drifting){selectClass = \" drifting\"}\n  return(\n  <div onClick={props.handleDriftToggle} className = {\"driftButton\" + selectClass} id = \"driftButton\">\n  FLOW\n  <div className=\"hoverLine\"></div>\n\n</div>\n  )\n})\n\nconst FXContainer = React.memo(function FXContainer(props: any) {\n  let fxIndex = -1;\n  return (\n    <div className=\"fxContainer\">\n      {props.showUI?(\n      <div className=\"fxUI trackSliders\">\n        {soundSources.map((track: any, index: number) => {\n          if (track.kind === \"fx\") {\n            fxIndex ++;\n            return (\n              <FXUI\n                index={index}\n                fxIndex={fxIndex}\n                volume={props.tracks[keys.volKey + index]}\n                disabled={props.tracks[keys.disabledKey + index]}\n                key={index}\n                handleVolumeChange={props.handleVolumeChange}\n                handleDriftToggle={props.handleDriftToggle}\n                handleDisableToggle={props.handleDisableToggle}\n              />\n            );\n          }\n        })}\n      </div>\n      ) : (\n        <div className = \"fxIndicator\" onClick={props.handleFxUIToggle}>FX</div>\n      )}\n    </div>\n  );\n})\n\nconst FXUI = React.memo(function FXUI(props: any){\n  return (\n    <div className=\"fxSlider\">\n      <IconContainer icon1={\"\"}/>\n      <div className=\"\">\n        <ControlledSlider\n          value={props.volume}\n          onChange={props.handleVolumeChange}\n          disabled={props.disabled}\n          index={props.index}\n          min={0}\n          max={100}\n          step={1}\n        />\n      </div>\n      <IconContainer icon1={fxIcons[props.fxIndex]}/>\n    </div>\n  );\n})\n\nfunction ChordContainer(props: any) {\n  return (\n    <div className = \"chordContainer\">\n        {props.showUI ? (\n        <div className=\"chordProgression\">\n          <ChordButton\n            value = {chords[props.progression[0]].value}\n            name = {chords[props.progression[0]].name}\n            currentBarInProgression = {props.currentBarInProgression}\n            index = {0}\n            handleChordClick={props.handleChordClick}\n            id = \"firstChord\"\n          />\n          <ChordButton\n            value = {chords[props.progression[1]].value}\n            name = {chords[props.progression[1]].name}\n            currentBarInProgression = {props.currentBarInProgression}\n\n            index = {1}\n            handleChordClick={props.handleChordClick}\n            id = \"secondChord\"\n          />\n          <ChordButton\n            value = {chords[props.progression[2]].value}\n            name = {chords[props.progression[2]].name}\n            currentBarInProgression = {props.currentBarInProgression}\n\n            index = {2}\n            handleChordClick={props.handleChordClick}\n            id = \"thirdChord\"\n          />\n          <ChordButton\n            value = {chords[props.progression[3]].value}\n            name = {chords[props.progression[3]].name}\n            currentBarInProgression = {props.currentBarInProgression}\n\n            index = {3}\n            handleChordClick={props.handleChordClick}\n            id = \"lastChord\"\n          />\n        </div>\n\n        ) : (\n          <div onClick = {()=> props.handleChordUIToggle()} className = \"chordsButton\">Change Chord Progression</div>\n        )}\n    </div>\n  );\n}\n\nfunction IconContainer(props: any){\n  return (\n    <div className = \"iconContainer\">\n      <img className = \"icon\" src = {props.icon1}></img>\n    </div>\n  )\n}\n\nfunction ChordButton(props: any) {\n  let extraClass = \"\";\n  if (props.currentBarInProgression === props.index){extraClass = \" currentChord\"}\n  return (\n    <div\n      className={\"chordButton\" + extraClass}\n      onClick={() => props.handleChordClick(props.index)}\n      id = {props.id}\n    >\n      {props.name}\n    </div>\n  );\n}\n\nfunction ControlledSlider(props : any){\n  function handleChange(event : any){\n    props.onChange(event.target.value, props.index)\n  }\n  let verticalClass = \"\"\n  if (props.vertical){verticalClass = \" vertical\"}\n  let disabled : string;\n  props.disabled ? disabled = \"disabled\" : disabled = \"\";\n  return (\n    <input\n    className={\"slider \"+ disabled + verticalClass}\n    type=\"range\"\n    value={props.value}\n    onChange={handleChange}\n    disabled={props.disabled}\n    min={props.min}\n    max={props.max}\n    step={props.step}\n  ></input>\n  )\n}\n\nfunction initializeState(){\n  initState.bpm = 90;\n  initState.playing = true;\n  initState.drifting = false;\n\n  initState.showChordUI = false;\n  initState.showFxUI = false;\n\n  initState.appStarted = false;\n  initState.loaded = false;\n  initState.hideOpeningScreen = false;\n  initState.loadingAnimPoints = [];\n\n\n  initState.masterSeq = {\n    currentSequencePos : 0,\n    lastPlayTime: performance.now(),\n    barsPlayed : 0,\n    FXTimer: -FXLength,\n    newDrumSeq: randomArrEntry(drumChangeOptions),\n    newChord: randomArrEntry(chordChangeOptions),\n    tempoChangeTimer: randomArrEntry(tempoChangeOptions),\n    currentBarInProgression : 0,\n    progression : [5, 5, 4, 3],\n  }\n\n  initState.currentChord = chords[initState.masterSeq.progression[0]].value;\n\n  soundSources.forEach((track : any, index: number) => {\n\n    switch (track.kind){\n      case \"inst\":\n        initState[keys.volKey + index] = soundSources[index].initVolume;\n        initState[keys.actKey + index] = soundSources[index].initActivity;\n        initState[keys.volDriftKey + index] = 0;\n        initState[keys.actDriftKey + index] = 0;\n        initState[keys.disabledKey + index] = soundSources[index].initDisabled;\n        initState[keys.showTrack + index] = false;\n        initState[keys.nowPlaying + index] = false;\n        break;\n  \n      case \"drum\":\n        initState[keys.volKey + index] = soundSources[index].initVolume;\n        initState[keys.volDriftKey + index] = 0;\n        initState[keys.disabledKey + index] = soundSources[index].initDisabled;\n        initState[keys.patKey + index] = soundSources[index].initPattern + 1;\n        initState[keys.nowPlaying + index] = false;\n        break;\n\n      case \"fx\":\n        initState[keys.volKey + index] = soundSources[index].initVolume;\n        initState[keys.volDriftKey + index] = 0;\n        initState[keys.disabledKey + index] = soundSources[index].initDisabled;\n        break;\n    }\n  })\n}\n\nexport function randomArrEntry(arr : any){\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\nfunction playSequencers(state: any) {\n  let whosPlaying : any = {};\n  soundSources.forEach((track: any, index: any) => {\n    whosPlaying[keys.nowPlaying + index] = false;\n    if (!state[keys.disabledKey + index]) {\n      if (track.kind === \"inst\" || track.kind === \"drum\") {\n        let soundIndex =\n          state[keys.seqKey + index][state.masterSeq.currentSequencePos];\n        if (!isNaN(soundIndex)) {\n          soundSources[index].sounds[soundIndex].howl.play();\n          whosPlaying[keys.nowPlaying + index] = true;\n          ripple(index, state[keys.volKey + index], state.masterSeq.currentSequencePos)\n        }\n      }\n    }\n  });\n  return whosPlaying;\n}\n\nexport default App;\n\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts",["43","44"],"import { Howl, Howler } from \"howler\"\nimport { soundSources } from \"./soundsources\"\nimport { keys, seqLength, randomArrEntry } from \"./App\"\nimport { SSL_OP_NO_QUERY_MTU } from \"constants\";\n\nclass Sound {\n  howl: any;\n  chords: any;\n\n  constructor(url: string, baseVolume: number, initVolume: number, chords: string[]) {\n    this.howl = new Howl({\n      src: [url],\n      volume: baseVolume * (initVolume / 100)\n    })\n    this.chords = chords;\n  }\n}\n\n/*  for each track, initsoundPlayer loads every sample into a new howl, \n    together with the chords that particular sound can be played on it.\n    All these sounds are then pushed into a sequencer object, which controls the playback\n    \n    soundSources [\n        sounds: [{\n            howl: *ACTUAL SOUND*\n            chords [\"Array of chords it can be played on\"]\n        ]}\n    ]  \n*/\n\nexport function initSoundPlayer(state: any) {\n  Howler.volume(2);\n\n  soundSources.forEach((track: any, index: number) => {\n    let soundsArr: any[] = [];\n    switch (track.kind) {\n      case \"inst\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(\n              sample.sampleSource,\n              track.baseVolume,\n              track.initVolume,\n              sample.chords\n            )\n          );\n        });\n        track.sounds = soundsArr;\n        break;\n\n      case \"drum\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(\n              sample.sampleSource,\n              track.baseVolume,\n              track.initVolume,\n              sample.chords\n            )\n          );\n        });\n        track.sounds = soundsArr;\n        break;\n\n      case \"fx\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(\n              sample.sampleSource,\n              track.baseVolume,\n              track.initVolume,\n              sample.chords\n            )\n          );\n        });\n        track.sounds = soundsArr;\n        break;\n    }    \n  });\n}\n\n\nexport function setTrackVolume(volume: number, index: number) {\n  soundSources[index].sounds.forEach((sound: any) => {\n    sound.howl.volume(\n      (volume / 100) * soundSources[index].baseVolume\n    );\n  });\n}\n\nexport function stopAllSounds(index: number) {\n  soundSources[index].sounds.forEach((sound: any) => {\n    sound.howl.stop();\n  });\n}\n\nfunction getRandomIntButNotThisOne(range: number, current: number) {\n  let out = Math.floor(Math.random() * range);\n  if (out === current) {\n    out = getRandomIntButNotThisOne(range, out);\n  }\n  return out;\n}\n\nfunction getNextSoundIndex(sounds: object[], currentChord: string) {\n  let newSoundIndex: number;\n  let newSoundOptions: number[] = [];\n  sounds.forEach((sound: any, index: number) => {\n    if (sound.chords.includes(currentChord)) {\n      newSoundOptions.push(index);\n    }\n  });\n  newSoundIndex = randomArrEntry(newSoundOptions);\n\n  return newSoundIndex;\n}\n\nexport function playFX(state: any){\n  soundSources.forEach((track: any, index: any) => {\n    if (track.kind === \"fx\"){\n      if (!state[keys.disabledKey + index]){\n      track.sounds[0].howl.play();\n      }\n    }\n  });\n}\n\nexport function randomMutation(\n  iterations: number,\n  startingSeq: number[],\n  sounds: any,\n  tonal: boolean,\n  currentChord: string\n) {\n  let newSeq = [...startingSeq];\n  for (let i = 0; i < iterations; i++) {\n    let emptyIndexes: number[] = [];\n    let filledIndexes: number[] = [];\n    newSeq.forEach((step: number, index: number) => {\n      isNaN(step) ? emptyIndexes.push(index) : filledIndexes.push(index);\n    });\n    if (tonal){\n      newSeq[\n        emptyIndexes[Math.floor(Math.random() * emptyIndexes.length)]\n      ] = getNextSoundIndex(sounds, currentChord)\n    } else {\n      newSeq[\n        emptyIndexes[Math.floor(Math.random() * emptyIndexes.length)]\n      ] = Math.floor(Math.random() * sounds.length);\n    }\n\n    newSeq[\n      filledIndexes[Math.floor(Math.random() * filledIndexes.length)]\n    ] = NaN;\n  }\n  return newSeq;\n}\n\n\nexport function buildFromActivity(\n  currentChord: string,\n  sounds: any[],\n  activity: number,\n  minNotes: number,\n  maxNotes: number,\n) {\n  let noteAmt = calcAmountOfNotes(minNotes, maxNotes, activity);\n  let currentSequence = [];\n  let possibleIndexes = [];\n  for (let i = 0; i < seqLength; i++) {\n    currentSequence.push(NaN);\n    possibleIndexes.push(i);\n  }\n  for (let i = 0; i < noteAmt; i++) {\n    let newSeqIndex = possibleIndexes[Math.floor(Math.random() * seqLength)];\n    let newSoundIndex = getNextSoundIndex(sounds, currentChord);\n    currentSequence[newSeqIndex] = newSoundIndex;\n    possibleIndexes.splice(newSeqIndex, 1);\n  }\n  return currentSequence;\n}\n\nexport function buildFromPattern(patternIndex : number, patterns: any[], sounds: any[]){\n  let newSeq = [...patterns[patternIndex]];\n  newSeq.forEach((step : number, index : number)=>{\n    if (!isNaN(step)){\n      newSeq[index] = Math.floor(Math.random() * sounds.length)\n    }\n  })\n  return newSeq;\n}\n\nfunction calcAmountOfNotes(min: number, max: number, activity: number) {\n  return min + Math.floor((activity / 100) * max);\n}\n\nexport function updateActivity(\n  currentChord: string,\n  sounds: any[],\n  activity: number,\n  minNotes: number,\n  maxNotes: number,\n  currentSequence: number[]\n) {\n  let noteAmt = calcAmountOfNotes(minNotes, maxNotes, activity);\n  let currentSequenceNoteIndices: number[] = [];\n  let currentSequenceEmptyIndices: number[] = [];\n  let editIndex: number;\n  let noteDifference: number;\n\n  currentSequence.forEach((seqItem: number, index: number) => {\n    if (!isNaN(seqItem)) {\n      currentSequenceNoteIndices.push(index);\n    } else {\n      currentSequenceEmptyIndices.push(index);\n    }\n  });\n\n  noteDifference = noteAmt - currentSequenceNoteIndices.length;\n  if (noteDifference < 0) {\n    for (let i = 0; i > noteDifference; i--) {\n      editIndex = Math.floor(Math.random() * currentSequenceNoteIndices.length);\n      currentSequence[currentSequenceNoteIndices[editIndex]] = NaN;\n      currentSequenceNoteIndices.splice(editIndex, 1);\n    }\n  } else if (noteDifference > 0) {\n    for (let i = 0; i < noteDifference; i++) {\n      editIndex = Math.floor(\n        Math.random() * currentSequenceEmptyIndices.length\n      );\n      currentSequence[\n        currentSequenceEmptyIndices[editIndex]\n      ] = getNextSoundIndex(sounds, currentChord);\n      currentSequenceEmptyIndices.splice(editIndex, 1);\n    }\n  }\n\n  return currentSequence;\n}\n\nexport function updateSeqChords(currentChord : string, sounds: any, currentSequence: number[]) {\n    currentSequence.forEach((seqItem: number, seqIndex: number) => {\n      if (!isNaN(seqItem)) {\n        if (!sounds[seqItem].chords.includes(currentChord)) {\n          currentSequence[seqIndex] = getNextSoundIndex(\n            sounds,\n            currentChord\n          );\n        }\n      }\n    });\n\n    return currentSequence;\n}\n\n\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/visuals.ts",[],["45","46"],{"ruleId":"47","replacedBy":"48"},{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","severity":1,"message":"52","line":546,"column":53,"nodeType":"53","messageId":"54","endLine":546,"endColumn":55},{"ruleId":"55","severity":1,"message":"56","line":588,"column":47,"nodeType":"57","messageId":"58","endLine":588,"endColumn":55},{"ruleId":"51","severity":1,"message":"52","line":662,"column":55,"nodeType":"53","messageId":"54","endLine":662,"endColumn":57},{"ruleId":"59","severity":1,"message":"60","line":695,"column":9,"nodeType":"61","endLine":695,"endColumn":51},{"ruleId":"59","severity":1,"message":"60","line":704,"column":9,"nodeType":"61","endLine":704,"endColumn":51},{"ruleId":"51","severity":1,"message":"52","line":733,"column":55,"nodeType":"53","messageId":"54","endLine":733,"endColumn":57},{"ruleId":"59","severity":1,"message":"60","line":830,"column":7,"nodeType":"61","endLine":830,"endColumn":51},{"ruleId":"55","severity":1,"message":"62","line":4,"column":10,"nodeType":"57","messageId":"58","endLine":4,"endColumn":29},{"ruleId":"55","severity":1,"message":"63","line":100,"column":11,"nodeType":"57","messageId":"58","endLine":100,"endColumn":36},{"ruleId":"47","replacedBy":"64"},{"ruleId":"49","replacedBy":"65"},"no-native-reassign",["66"],"no-negated-in-lhs",["67"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","@typescript-eslint/no-unused-vars","'disabled' is assigned a value but never used.","Identifier","unusedVar","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'SSL_OP_NO_QUERY_MTU' is defined but never used.","'getRandomIntButNotThisOne' is defined but never used.",["66"],["67"],"no-global-assign","no-unsafe-negation"]