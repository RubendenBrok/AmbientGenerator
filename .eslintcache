[{"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx":"1","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts":"2","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx":"3","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts":"4","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts":"5","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts":"6"},{"size":502,"mtime":1612791791000,"results":"7","hashOfConfig":"8"},{"size":425,"mtime":1611927196000,"results":"9","hashOfConfig":"8"},{"size":8908,"mtime":1612795964000,"results":"10","hashOfConfig":"8"},{"size":1572,"mtime":1612348977000,"results":"11","hashOfConfig":"8"},{"size":9378,"mtime":1612795853000,"results":"12","hashOfConfig":"8"},{"size":7667,"mtime":1612785573000,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"asqc5z",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"16"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"16"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx",[],["30","31"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx",["32","33","34"],"import { request } from \"https\";\nimport React, { useState } from \"react\";\nimport { updateTrackDrift } from \"./drift\"\nimport { initSoundPlayer, updateSoundPlayer, setTrackVolume, setTrackDisable, updateTrackActivity, toggleRhythmic, updateBPM, updateCurrentSequenceChords} from \"./soundplayer\"\nimport \"./App.css\";\nimport { isPropertySignature } from \"typescript\";\n\nexport class App extends React.Component<any, any> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      tracks: [\n        {\n          index: 0,\n          volume: 50,\n          activity: 50,\n          volDriftVelocity: 0,\n          actDriftVelocity: 0,\n          drifting: false,\n          disabled: false,\n        },\n        {\n          index: 1,\n          volume: 50,\n          activity: 50,\n          volDriftVelocity: 0,\n          actDriftVelocity: 0,\n          drifting: false,\n          disabled: false,\n        },\n        {\n          index: 2,\n          volume: 50,\n          activity: 50,\n          volDriftVelocity: 0,\n          actDriftVelocity: 0,\n          drifting: false,\n          disabled: false,\n        },\n        {\n          index: 3,\n          volume: 50,\n          activity: 50,\n          volDriftVelocity: 0,\n          actDriftVelocity: 0,\n          drifting: false,\n          disabled: false,\n        },\n        //{ index: 4, volume: 50, activity: 50, volDriftVelocity: 0, actDriftVelocity: 0, drifting: false, disabled: false},\n      ],\n      currentChord: \"G\",\n      rhythmic: false,\n      bpm: 100,\n    };\n\n    this.appLoop = this.appLoop.bind(this);\n    this.handleVolumeChange = this.handleVolumeChange.bind(this);\n    this.handleActivityChange = this.handleActivityChange.bind(this);\n    this.handleDriftToggle = this.handleDriftToggle.bind(this);\n    this.handleDisableToggle = this.handleDisableToggle.bind(this);\n    this.handleBpmChange = this.handleBpmChange.bind(this);\n    this.handleRhythmicToggle = this.handleRhythmicToggle.bind(this);\n    this.handleChordClick = this.handleChordClick.bind(this);\n  }\n\n  appLoop() {\n    const newTrackState = updateTrackDrift(this.state.tracks);\n    newTrackState.forEach((track: any, index: number) => {\n      if (track.volume !== this.state.volume) {\n        this.handleVolumeChange(track.volume, index);\n      }\n      if (track.activity !== this.state.activity) {\n        this.handleActivityChange(track.activity, index);\n      }\n    });\n\n    updateSoundPlayer(this.state.rhythmic)\n\n    window.requestAnimationFrame(this.appLoop);\n  }\n\n  handleVolumeChange(value: any, index: number) {\n    let newTrackState = this.state.tracks;\n    newTrackState[index].volume = parseFloat(value);\n    this.setState({ tracks: newTrackState }, () =>\n      setTrackVolume(this.state.tracks[index].volume, index)\n    );\n  }\n\n  handleActivityChange(value: any, index: number) {\n    let newTrackState = this.state.tracks;\n    newTrackState[index].activity = parseFloat(value);\n    this.setState({ tracks: newTrackState }, () =>\n      updateTrackActivity(this.state.tracks[index].activity, index)\n    );\n  }\n\n  handleDriftToggle(value :boolean, index: number) {\n    let newTrackState = this.state.tracks;\n    newTrackState[index].drifting = value;\n    this.setState({ tracks: newTrackState });\n  }\n\n  handleDisableToggle(value : boolean, index: number) {\n    let newTrackState = this.state.tracks;\n    newTrackState[index].disabled = !value;\n    this.setState({ tracks: newTrackState }, () => {\n      setTrackDisable(this.state.tracks, index);\n    });\n  }\n\n  handleChordClick(chord: string) {\n    if (chord !== this.state.currentChord){\n      this.setState({ currentChord: chord }, () => updateCurrentSequenceChords(this.state.currentChord));\n    }\n  }\n\n  handleBpmChange(newBpm : number){\n    this.setState( {bpm : newBpm}, () => updateBPM(this.state.bpm, this.state.rhythmic) )\n  }\n\n  handleRhythmicToggle(value : boolean){\n    this.setState( {rhythmic : value}, () => toggleRhythmic(this.state.rhythmic, this.state.bpm) )\n  }\n\n\n\n  render() {\n    return (\n      <div>\n        <FaderContainer\n          numberOfTracks={this.state.numberOfTracks}\n          tracks={this.state.tracks}\n          handleVolumeChange={this.handleVolumeChange}\n          handleActivityChange={this.handleActivityChange}\n          handleDriftToggle={this.handleDriftToggle}\n          handleDisableToggle={this.handleDisableToggle}\n        />\n        <RhythmContainer\n          rhythmic={this.state.rhythmic}\n          bpm={this.state.bpm}\n          handleBpmChange={this.handleBpmChange}\n          handleRhythmicToggle={this.handleRhythmicToggle}\n        />\n        <ChordContainer\n          currentChord={this.state.currentChord}\n          handleChordClick={this.handleChordClick}\n        />\n      </div>\n    );\n  }\n\n  componentDidMount() {\n    initSoundPlayer(this.state.tracks, this.state.bpm, this.state.currentChord, this.state.rhythmic);\n    this.appLoop();\n  }\n} \n\nfunction FaderContainer(props : any){\n    return (\n      <div className = \"FaderContainer\">\n        {props.tracks.map((track : any) => {\n          return (\n            <TrackUI \n              index = {track.index} \n              volume = {track.volume} \n              activity = {track.activity} \n              disabled = {track.disabled}\n              key = {track.index} \n              handleVolumeChange = {props.handleVolumeChange}\n              handleActivityChange = {props.handleActivityChange}\n              handleDriftToggle = {props.handleDriftToggle}\n              handleDisableToggle = {props.handleDisableToggle}\n              />\n          )})\n        }\n      </div>\n    )\n}\n\n//class TrackUI extends React.Component<any, any> {\nfunction TrackUI(props : any) {\n    return (\n      <div className=\"TrackUI\">\n        <p>This is track number {props.index}</p>\n        <p>its volume is {Math.round(props.volume)}</p>\n        <p>\n          <ControlledSlider\n            value={props.volume}\n            onChange={props.handleVolumeChange}\n            disabled={props.disabled}\n            index={props.index}\n            min={0}\n            max={100}\n          />\n        </p>\n        <p>its activity is {Math.round(props.activity)}</p>\n        <p>\n          <ControlledSlider\n            value={props.activity}\n            onChange={props.handleActivityChange}\n            disabled={props.disabled}\n            index={props.index}\n            min={0}\n            max={100}\n          />\n        </p>\n        <p>\n          Drift:{\" \"}\n          <ControlledCheckbox\n            index={props.index}\n            checked={props.drifting}\n            onChange={props.handleDriftToggle}\n            disabled={props.disabled}\n          />\n        </p>\n        <p>\n          Enabled:{\" \"}\n          <ControlledCheckbox\n            index={props.index}\n            checked={!props.disabled}\n            onChange={props.handleDisableToggle}\n            disabled={false}\n          />\n        </p>\n      </div>\n    );\n  }\n\nfunction RhythmContainer(props : any){\n  return (\n    <div className = \"RhythmContainer\">\n    <p>Rhythmic:{\" \"}\n    <ControlledCheckbox \n      index = {0}\n      checked = {props.rhythmic}\n      onChange = {props.handleRhythmicToggle}\n      disabled = {false}\n    />\n    </p>\n    <p>\n      The current BPM is {props.bpm}\n    </p>\n    <ControlledSlider \n      index = {0}\n      value = {props.bpm}\n      onChange = {props.handleBpmChange}\n      min={40}\n      max={130}\n      />\n    </div>\n  )\n}\n\n\nfunction ChordContainer(props : any){\n  return (\n    <div className = \"ChordContainer\">\n      <ChordButton value = \"G\" name = \"G\" handleChordClick = {props.handleChordClick} />\n      <ChordButton value = \"A\" name = \"Am\" handleChordClick = {props.handleChordClick} />\n      <ChordButton value = \"B\" name = \"Bm\" handleChordClick = {props.handleChordClick} />\n      <ChordButton value = \"C\" name = \"C\" handleChordClick = {props.handleChordClick} />\n      <ChordButton value = \"D\" name = \"D\" handleChordClick = {props.handleChordClick} />\n      <ChordButton value = \"E\" name = \"Em\" handleChordClick = {props.handleChordClick} />\n      the current chord is {props.currentChord}\n    </div>\n  )\n}\n\nfunction ChordButton(props : any){\n  return (\n    <div className = \"ChordButton\">\n      <button onClick = { () => props.handleChordClick(props.value) }>\n      {props.name}</button>\n    </div>\n  )\n}\n\nfunction ControlledSlider(props : any){\n  function handleChange(event : any){\n    props.onChange(event.target.value, props.index)\n  }\n  return (\n    <input\n    type=\"range\"\n    value={props.value}\n    onChange={handleChange}\n    disabled={props.disabled}\n    min={props.min}\n    max={props.max}\n  ></input>\n  )\n}\n\nfunction ControlledCheckbox(props : any){\n  function handleChange(event : any){\n    props.onChange(event.target.checked, props.index)\n  }\n  return (\n    <input\n    type=\"checkbox\"\n    checked={props.checked}\n    onChange={handleChange}\n    disabled={props.disabled}\n  ></input>\n  )\n}\n\n\nexport default App;\n\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts",["35","36","37","38","39","40"],"import { time } from \"console\";\nimport { timingSafeEqual } from \"crypto\";\nimport { Howl, Howler } from \"howler\"\nimport { start } from \"repl\";\nimport { soundSources, drumSources } from \"./soundsources\"\n\nconst chordOptions = [\"G\",\"A\",\"B\",\"C\",\"D\",\"E\"];\n\nconst maxSoundsInSequence = 10\nconst minSoundsInSequence = 1\nconst freeBPM = 10;\nconst freeBPMRandomness = 10\nconst sequenceLength = 32\n\nclass Sequencer {\n  disabled: boolean;\n  sounds: any[];\n  bpm: number;\n  currentSequence: number[];\n  startOfSequence: number;\n  currentSequencePos: number;\n  currentSoundIndex: number;\n  nextSequencePos: number;\n  currentChord: string;\n  activity: number;\n  noteAmt: number;\n  patterns: any;\n  tonal : boolean;\n\n  constructor(\n    sounds: any[],\n    bpm: number,\n    currentChord: string,\n    activity: number,\n    disabled: boolean,\n    patterns: any,\n    tonal: boolean\n  ) {\n    this.sounds = sounds;\n    this.disabled = disabled;\n    this.bpm = bpm;\n    this.startOfSequence = performance.now();\n    this.currentSequencePos = 0;\n    this.currentSoundIndex = 0;\n    this.nextSequencePos = 0;\n    this.currentChord = currentChord;\n    this.currentSequence = [];\n    this.activity = activity;\n    this.noteAmt = 0;\n    this.patterns = patterns;\n    this.tonal = tonal;\n\n    this.build();\n  }\n\n  calcAmountOfNotes() {\n    this.noteAmt =\n      minSoundsInSequence +\n      Math.floor((this.activity / 100) * maxSoundsInSequence);\n  }\n\n  build() {\n    if (this.patterns) {\n      this.currentSequence = this.patterns[\n        Math.floor(Math.random() * this.patterns.length)\n      ];\n    } else {\n      this.calcAmountOfNotes();\n      this.currentSequence = [];\n      let possibleIndexes = [];\n      for (let i = 0; i < sequenceLength; i++) {\n        this.currentSequence.push(NaN);\n        possibleIndexes.push(i);\n      }\n      for (let i = 0; i < this.noteAmt; i++) {\n        let newSeqIndex =\n          possibleIndexes[Math.floor(Math.random() * sequenceLength)];\n        let newSoundIndex = getNextSoundIndex(this.sounds, this.currentChord);\n        this.currentSequence[newSeqIndex] = newSoundIndex;\n        possibleIndexes.splice(newSeqIndex, 1);\n      }\n    }\n  }\n\n  updateAndPlay() {\n    this.calcSequencePos();\n    if (this.currentSequencePos >= 32) {\n      this.restart();\n    }\n\n    if (this.currentSequencePos === this.nextSequencePos) {\n      if (!isNaN(this.currentSequence[this.currentSequencePos])) {\n        //this.sounds[this.currentSoundIndex].howl.stop();\n        if (!this.disabled) {\n          this.sounds[this.currentSequence[this.currentSequencePos]].howl.play();\n          this.currentSoundIndex = this.currentSequence[this.currentSequencePos];\n        }\n      }\n      this.nextSequencePos++;\n    }\n  }\n\n  restart() {\n    this.startOfSequence = performance.now();\n    this.currentSequencePos = 0;\n    this.nextSequencePos = 0;\n  }\n\n  mutate() {}\n\n  updateChords() {\n    if (this.tonal) {\n      this.currentSequence.forEach((seqItem: number, seqIndex: number) => {\n        if (!isNaN(seqItem)) {\n          if (!this.sounds[seqItem].chords.includes(this.currentChord)) {\n            this.currentSequence[seqIndex] = getNextSoundIndex(\n              this.sounds,\n              this.currentChord\n            );\n          }\n        }\n      });\n    }\n  }\n\n  updateActivity(){\n    this.calcAmountOfNotes();\n    let currentSequenceNoteIndices : number[] = [];\n    let currentSequenceEmptyIndices : number[] = [];\n    let editIndex : number;\n    let noteDifference : number;\n\n    this.currentSequence.forEach((seqItem : number, index: number) => {\n        if (!isNaN(seqItem)){\n            currentSequenceNoteIndices.push(index)\n        }   else {\n            currentSequenceEmptyIndices.push(index)\n        }\n    })\n\n    noteDifference = this.noteAmt - currentSequenceNoteIndices.length\n    if (noteDifference < 0){\n        for (let i = 0; i > noteDifference; i--){\n            editIndex = Math.floor(Math.random() * currentSequenceNoteIndices.length);\n            this.currentSequence[currentSequenceNoteIndices[editIndex]] = NaN;\n            currentSequenceNoteIndices.splice(editIndex, 1)\n        }\n    } else if (noteDifference > 0){\n        for (let i = 0; i < noteDifference; i++){\n            editIndex = Math.floor(Math.random() * currentSequenceEmptyIndices.length);\n            this.currentSequence[currentSequenceEmptyIndices[editIndex]] = getNextSoundIndex(this.sounds, this.currentChord);\n            currentSequenceEmptyIndices.splice(editIndex, 1)\n        }\n    }\n  }\n\n  calcSequencePos() {\n    let sixteenth = (60 / this.bpm / 4) * 1000;\n    let timePassed = performance.now() - this.startOfSequence;\n    this.currentSequencePos = Math.floor(timePassed / sixteenth);\n  }\n}\n\nclass Sound {\n  howl: any;\n  chords: any;\n\n  constructor(url: string, baseVolume: number, chords: Array<string>) {\n    this.howl = new Howl({\n      src: [url],\n      volume: baseVolume,\n\n    });\n    this.chords = chords;\n  }\n}\n\n/*  for each track, initsoundPlayer loads every sample into a new howl, \n    together with the chords that particular sound can be played on it.\n    All these sounds are then pushed into a sequencer object, which controls the playback\n    \n    soundSources [\n        sequencer :\n            sounds: [{\n                howl: *ACTUAL SOUND*\n                chords [\"Array of chords it can be played on\"]\n            ]}\n    ]  \n*/\n\nexport function initSoundPlayer(\n  trackState: any,\n  bpm: number,\n  chord: string,\n  rhythmic: boolean\n) {\n  soundSources.forEach((track: any, index: number) => {\n    let soundsArr: any[] = [];\n    track.sampleLoader.forEach((sample: any) => {\n      soundsArr.push(\n        new Sound(sample.sampleSource, track.baseVolume, sample.chords)\n      );\n    });\n    track.sequencer = new Sequencer(\n      soundsArr,\n      bpm,\n      chord,\n      trackState[index].activity,\n      trackState[index].disabled,\n      false,\n      true\n    );\n    toggleRhythmic(rhythmic, bpm);\n  });\n\n  drumSources.forEach((track: any, index: number) => {\n    let soundsArr: any[] = [];\n    track.sampleLoader.forEach((sample: any) => {\n      soundsArr.push(\n        new Sound(sample.sampleSource, track.baseVolume, sample.chords)\n      );\n    });\n    track.sequencer = new Sequencer(\n      soundsArr,\n      bpm,\n      chord,\n      100,\n      false,\n      track.patterns,\n      false\n    );\n    toggleRhythmic(rhythmic, bpm);\n  });\n}\n\n\nexport function updateSoundPlayer(rhythmic : boolean){\n    soundSources.forEach((track : any) => {\n        track.sequencer.updateAndPlay()\n    })\n\n    if (rhythmic){\n        drumSources.forEach((track : any) => {\n            track.sequencer.updateAndPlay();\n        })\n    }\n}\n\nexport function setTrackVolume(volume : number, index : number){\n    soundSources[index].currentVolume = volume / 100;\n    soundSources[index].sequencer.sounds.forEach((sound : any) => {\n        sound.howl.volume(soundSources[index].currentVolume * soundSources[index].baseVolume)\n    })\n}\n\nexport function updateTrackActivity(activity : number, index : number){\n    soundSources[index].sequencer.activity = activity;\n    soundSources[index].sequencer.updateActivity();\n}\n\nexport function setTrackDisable(trackData : any, index : number){\n    soundSources[index].sequencer.disabled = trackData[index].disabled\n    if (trackData[index].disabled){ stopAllSounds(index) }\n}\n\nfunction stopAllSounds(index : number){\n    soundSources[index].sequencer.sounds.forEach((sound : any) => {\n        sound.howl.stop()\n    })\n}\n\nfunction getRandomIntButNotThisOne(range : number, current : number){\n    let out = Math.floor(Math.random() * range);\n    if (out === current){\n        out = getRandomIntButNotThisOne(range, out)\n    }\n    return out\n}\n\nfunction getNextSoundIndex(sounds : object[], currentChord : string){\n    let newSoundIndex : number\n    let newSoundOptions : number[] = []\n\n    sounds.forEach((sound : any, index : number) => {\n        if (sound.chords.includes(currentChord)){\n            newSoundOptions.push(index)\n        }\n    })\n    newSoundIndex = newSoundOptions[Math.floor(Math.random() * newSoundOptions.length)]\n    return newSoundIndex\n}\n\nexport function toggleRhythmic(rhythmic : boolean, bpm : number){\n    if (rhythmic){\n        soundSources.forEach((track : any, index : any) => {\n            track.sequencer.bpm = bpm;\n            track.sequencer.build();\n            track.sequencer.restart();\n        }) \n        drumSources.forEach((track : any, index : any) => {\n            track.sequencer.bpm = bpm;\n            track.sequencer.build();\n            track.sequencer.restart();\n        }) \n    } else {\n        soundSources.forEach((track : any, index : any) => {\n            track.sequencer.bpm = freeBPM + Math.random() * freeBPMRandomness;\n        }) \n    }\n}\n\nexport function updateBPM(bpm : number, rhythmic : boolean){\n    if (rhythmic){\n        soundSources.forEach((track : any, index : any) => {\n            track.sequencer.bpm = bpm;\n        })\n        drumSources.forEach((track : any, index : any) => {\n            track.sequencer.bpm = bpm;\n        })\n    } \n}\n\nexport function updateCurrentSequenceChords(currentChord : string){\n    soundSources.forEach((track : any, index : any) => {\n        track.sequencer.currentChord = currentChord;\n        track.sequencer.updateChords();\n    })\n}\n\nfunction newRandomChord(){\n    updateCurrentSequenceChords(chordOptions[Math.floor(Math.random() * 6)])\n}\n\n\n\n\n\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts",[],["41","42"],{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":1,"column":10,"nodeType":"49","messageId":"50","endLine":1,"endColumn":17},{"ruleId":"47","severity":1,"message":"51","line":2,"column":17,"nodeType":"49","messageId":"50","endLine":2,"endColumn":25},{"ruleId":"47","severity":1,"message":"52","line":6,"column":10,"nodeType":"49","messageId":"50","endLine":6,"endColumn":29},{"ruleId":"47","severity":1,"message":"53","line":1,"column":10,"nodeType":"49","messageId":"50","endLine":1,"endColumn":14},{"ruleId":"47","severity":1,"message":"54","line":2,"column":10,"nodeType":"49","messageId":"50","endLine":2,"endColumn":25},{"ruleId":"47","severity":1,"message":"55","line":3,"column":16,"nodeType":"49","messageId":"50","endLine":3,"endColumn":22},{"ruleId":"47","severity":1,"message":"56","line":4,"column":10,"nodeType":"49","messageId":"50","endLine":4,"endColumn":15},{"ruleId":"47","severity":1,"message":"57","line":275,"column":15,"nodeType":"49","messageId":"50","endLine":275,"endColumn":40},{"ruleId":"47","severity":1,"message":"58","line":330,"column":10,"nodeType":"49","messageId":"50","endLine":330,"endColumn":24},{"ruleId":"43","replacedBy":"59"},{"ruleId":"45","replacedBy":"60"},"no-native-reassign",["61"],"no-negated-in-lhs",["62"],"@typescript-eslint/no-unused-vars","'request' is defined but never used.","Identifier","unusedVar","'useState' is defined but never used.","'isPropertySignature' is defined but never used.","'time' is defined but never used.","'timingSafeEqual' is defined but never used.","'Howler' is defined but never used.","'start' is defined but never used.","'getRandomIntButNotThisOne' is defined but never used.","'newRandomChord' is defined but never used.",["61"],["62"],"no-global-assign","no-unsafe-negation"]