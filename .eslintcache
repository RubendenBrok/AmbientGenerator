[{"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx":"1","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts":"2","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx":"3","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts":"4","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts":"5","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts":"6"},{"size":502,"mtime":1612791791000,"results":"7","hashOfConfig":"8"},{"size":425,"mtime":1611927196000,"results":"9","hashOfConfig":"8"},{"size":9759,"mtime":1612877338000,"results":"10","hashOfConfig":"8"},{"size":1025,"mtime":1612876319000,"results":"11","hashOfConfig":"8"},{"size":9842,"mtime":1612877310000,"results":"12","hashOfConfig":"8"},{"size":11177,"mtime":1612872009000,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"asqc5z",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":"25"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx",[],["28","29"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx",["30"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts",["31","32","33","34"],"import { Howl } from \"howler\"\nimport { soundSources } from \"./soundsources\"\nimport { keys } from \"./App\"\n\nconst chordOptions = [\"G\",\"A\",\"B\",\"C\",\"D\",\"E\"];\n\nconst maxSoundsInSequence = 10\nconst minSoundsInSequence = 1\nconst freeBPM = 10;\nconst freeBPMRandomness = 10\nconst sequenceLength = 32\n\nwindow.onload = () => {\n  masterSeq.playing = true;\n  masterSeq.restart();\n}\n\nclass MasterSeq {\n  bpm: number;\n  startOfSequence: number;\n  currentSequencePos: number;\n  nextSequencePos: number;\n  currentChord: string;\n  barsPlayed: number;\n  playing: boolean;\n\n  constructor() {\n    this.bpm = 0;\n    this.startOfSequence = performance.now();\n    this.currentSequencePos = 0;\n    this.nextSequencePos = 0;\n    this.currentChord = \"\";\n    this.barsPlayed = 0;\n    this.playing = false;\n  }\n\n  advanceSequence() {\n    if (this.playing) {\n      this.calcSequencePos();\n      if (this.currentSequencePos >= 32) {\n        this.barsPlayed++;\n        if (this.barsPlayed % 2 === 0){\n          newRandomChord();\n        }\n        this.restart();\n      }\n\n      if (this.currentSequencePos === this.nextSequencePos) {\n        soundSources.forEach((track: any) => {\n          if (track.kind === \"inst\" || track.kind === \"drum\")\n          track.sequencer.playCurrentSequencePos();\n        });\n\n        this.nextSequencePos++;\n      }\n    }\n  }\n\n  calcSequencePos() {\n    let sixteenth = (60 / this.bpm / 4) * 1000;\n    let timePassed = performance.now() - this.startOfSequence;\n    this.currentSequencePos = Math.floor(timePassed / sixteenth);\n  }\n\n  restart() {\n    this.startOfSequence = performance.now();\n    this.currentSequencePos = 0;\n    this.nextSequencePos = 0;\n  }\n}\nconst masterSeq = new MasterSeq\n\n\nclass Sequencer {\n  disabled: boolean;\n  sounds: any[];\n  currentSequence: number[];\n  currentSoundIndex: number;\n  activity: number;\n  noteAmt: number;\n  patterns: any;\n  tonal : boolean;\n  maxSoundsInSequence: number;\n  minSoundsInSequence: number;\n\n  constructor(\n    sounds: any[],\n    activity: number,\n    disabled: boolean,\n    patterns: any,\n    tonal: boolean,\n    maxSoundsInSequence: number,\n    minSoundsInSequence: number,\n  ) {\n    this.sounds = sounds;\n    this.disabled = disabled;\n    this.currentSequence = [];\n    this.activity = activity;\n    this.noteAmt = 0;\n    this.patterns = patterns;\n    this.tonal = tonal;\n    this.currentSoundIndex = 0;\n    this.maxSoundsInSequence = maxSoundsInSequence\n    this.minSoundsInSequence = minSoundsInSequence\n\n    this.build();\n  }\n\n  calcAmountOfNotes() {\n    this.noteAmt =\n      this.minSoundsInSequence +\n      Math.floor((this.activity / 100) * this.maxSoundsInSequence);\n  }\n\n  build() {\n    if (this.patterns) {\n      this.currentSequence = this.patterns[\n        Math.floor(Math.random() * this.patterns.length)\n      ];\n    } else {\n      this.calcAmountOfNotes();\n      this.currentSequence = [];\n      let possibleIndexes = [];\n      for (let i = 0; i < sequenceLength; i++) {\n        this.currentSequence.push(NaN);\n        possibleIndexes.push(i);\n      }\n      for (let i = 0; i < this.noteAmt; i++) {\n        let newSeqIndex =\n          possibleIndexes[Math.floor(Math.random() * sequenceLength)];\n        let newSoundIndex = getNextSoundIndex(this.sounds, masterSeq.currentChord);\n        this.currentSequence[newSeqIndex] = newSoundIndex;\n        possibleIndexes.splice(newSeqIndex, 1);\n      }\n    }\n  }\n\n  playCurrentSequencePos(){\n      if (!isNaN(this.currentSequence[masterSeq.currentSequencePos])) {\n        //this.sounds[this.currentSoundIndex].howl.stop();\n        if (!this.disabled) {\n          this.sounds[this.currentSequence[masterSeq.currentSequencePos]].howl.play();\n          this.currentSoundIndex = this.currentSequence[masterSeq.currentSequencePos];\n        }\n      }  \n  }\n\n  mutate() {}\n\n  updateChords() {\n    if (this.tonal) {\n      this.currentSequence.forEach((seqItem: number, seqIndex: number) => {\n        if (!isNaN(seqItem)) {\n          if (!this.sounds[seqItem].chords.includes(masterSeq.currentChord)) {\n            this.currentSequence[seqIndex] = getNextSoundIndex(\n              this.sounds,\n              masterSeq.currentChord\n            );\n          }\n        }\n      });\n    }\n  }\n\n  updateActivity(){\n    this.calcAmountOfNotes();\n    let currentSequenceNoteIndices : number[] = [];\n    let currentSequenceEmptyIndices : number[] = [];\n    let editIndex : number;\n    let noteDifference : number;\n\n    this.currentSequence.forEach((seqItem : number, index: number) => {\n        if (!isNaN(seqItem)){\n            currentSequenceNoteIndices.push(index)\n        }   else {\n            currentSequenceEmptyIndices.push(index)\n        }\n    })\n\n    noteDifference = this.noteAmt - currentSequenceNoteIndices.length\n    if (noteDifference < 0){\n        for (let i = 0; i > noteDifference; i--){\n            editIndex = Math.floor(Math.random() * currentSequenceNoteIndices.length);\n            this.currentSequence[currentSequenceNoteIndices[editIndex]] = NaN;\n            currentSequenceNoteIndices.splice(editIndex, 1)\n        }\n    } else if (noteDifference > 0){\n        for (let i = 0; i < noteDifference; i++){\n            editIndex = Math.floor(Math.random() * currentSequenceEmptyIndices.length);\n            this.currentSequence[currentSequenceEmptyIndices[editIndex]] = getNextSoundIndex(this.sounds, masterSeq.currentChord);\n            currentSequenceEmptyIndices.splice(editIndex, 1)\n        }\n    }\n  }\n}\n\nclass Sound {\n  howl: any;\n  chords: any;\n\n  constructor(url: string, baseVolume: number, chords: Array<string>) {\n    this.howl = new Howl({\n      src: [url],\n      volume: baseVolume,\n    });\n    this.chords = chords;\n  }\n}\n\n/*  for each track, initsoundPlayer loads every sample into a new howl, \n    together with the chords that particular sound can be played on it.\n    All these sounds are then pushed into a sequencer object, which controls the playback\n    \n    soundSources [\n        sequencer :\n            sounds: [{\n                howl: *ACTUAL SOUND*\n                chords [\"Array of chords it can be played on\"]\n            ]}\n    ]  \n*/\n\nexport function initSoundPlayer(state: any) {\n  masterSeq.bpm = state.bpm;\n  masterSeq.currentChord = state.currentChord;\n\n  soundSources.forEach((track: any, index: number) => {\n    let soundsArr: any[] = [];\n    switch (track.kind) {\n      case \"inst\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(sample.sampleSource, track.baseVolume, sample.chords)\n          );\n        });\n        track.sequencer = new Sequencer(\n          soundsArr,\n          state[keys.actKey + index],\n          state[keys.disabledKey + index],\n          false,\n          true,\n          track.maxSoundsInSequence,\n          track.minSoundsInSequence\n        );\n        break;\n\n      case \"drum\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(sample.sampleSource, track.baseVolume, sample.chords)\n          );\n        });\n        track.sequencer = new Sequencer(\n          soundsArr,\n          100,\n          state[keys.disabledKey + index].disabled,\n          track.patterns,\n          false,\n          track.maxSoundsInSequence,\n          track.minSoundsInSequence\n        );\n        break;\n    }\n  });\n}\n\n\nexport function updateSoundPlayer() {\n  masterSeq.advanceSequence();\n  return (masterSeq.currentChord);\n}\n\nexport function setTrackVolume(volume: number, index: number) {\n  soundSources[index].currentVolume = volume / 100;\n  soundSources[index].sequencer.sounds.forEach((sound: any) => {\n    sound.howl.volume(\n      soundSources[index].currentVolume * soundSources[index].baseVolume\n    );\n  });\n}\n\nexport function updateTrackActivity(activity: number, index: number) {\n  soundSources[index].sequencer.activity = activity;\n  soundSources[index].sequencer.updateActivity();\n}\n\nexport function setTrackDisable(disabled : boolean, index: number) {\n  soundSources[index].sequencer.disabled = disabled;\n  if (disabled) {\n    stopAllSounds(index);\n  }\n}\n\nfunction stopAllSounds(index: number) {\n  soundSources[index].sequencer.sounds.forEach((sound: any) => {\n    sound.howl.stop();\n  });\n}\n\nfunction getRandomIntButNotThisOne(range: number, current: number) {\n  let out = Math.floor(Math.random() * range);\n  if (out === current) {\n    out = getRandomIntButNotThisOne(range, out);\n  }\n  return out;\n}\n\nfunction getNextSoundIndex(sounds: object[], currentChord: string) {\n  let newSoundIndex: number;\n  let newSoundOptions: number[] = [];\n  sounds.forEach((sound: any, index: number) => {\n    if (sound.chords.includes(currentChord)) {\n      newSoundOptions.push(index);\n    }\n  });\n  newSoundIndex =\n    newSoundOptions[Math.floor(Math.random() * newSoundOptions.length)];\n\n  return newSoundIndex;\n}\n\nexport function toggleRhythmic(rhythmic: boolean, bpm: number) {\n  if (rhythmic) {\n    soundSources.forEach((track: any, index: any) => {\n      track.sequencer.bpm = bpm;\n      track.sequencer.build();\n      track.sequencer.restart();\n    });\n  } else {\n    soundSources.forEach((track: any, index: any) => {\n      track.sequencer.bpm = freeBPM + Math.random() * freeBPMRandomness;\n    });\n  }\n}\n\nexport function updateBPM(bpm: number, rhythmic: boolean) {\n  let timePassed = performance.now() - masterSeq.startOfSequence;\n  if (masterSeq.bpm !== bpm){\n    let rhythmScale = masterSeq.bpm / bpm;\n    masterSeq.startOfSequence = performance.now() - timePassed * rhythmScale;\n    masterSeq.bpm = bpm;\n  }\n}\n\nexport function updateCurrentSequenceChords(currentChord: string) {\n  masterSeq.currentChord = currentChord;\n  soundSources.forEach((track: any, index: any) => {\n    if (track.kind === \"inst\"){\n      track.sequencer.updateChords();\n    }\n  });\n}\n\nfunction newRandomChord() {\n  updateCurrentSequenceChords(chordOptions[Math.floor(Math.random() * 6)]);\n}\n\n\n\n\n\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts",[],{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","severity":1,"message":"40","line":145,"column":53,"nodeType":"41","messageId":"42","endLine":145,"endColumn":55},{"ruleId":"43","severity":1,"message":"44","line":7,"column":7,"nodeType":"45","messageId":"46","endLine":7,"endColumn":26},{"ruleId":"43","severity":1,"message":"47","line":8,"column":7,"nodeType":"45","messageId":"46","endLine":8,"endColumn":26},{"ruleId":"48","severity":1,"message":"49","line":71,"column":19,"nodeType":"50","messageId":"51","endLine":71,"endColumn":32,"fix":"52"},{"ruleId":"43","severity":1,"message":"53","line":303,"column":11,"nodeType":"45","messageId":"46","endLine":303,"endColumn":36},"no-native-reassign",["54"],"no-negated-in-lhs",["55"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","@typescript-eslint/no-unused-vars","'maxSoundsInSequence' is assigned a value but never used.","Identifier","unusedVar","'minSoundsInSequence' is assigned a value but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"56","text":"57"},"'getRandomIntButNotThisOne' is defined but never used.","no-global-assign","no-unsafe-negation",[1691,1691],"()"]