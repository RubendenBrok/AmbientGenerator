[{"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx":"1","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts":"2","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx":"3","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts":"4","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts":"5","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts":"6"},{"size":502,"mtime":1612791791000,"results":"7","hashOfConfig":"8"},{"size":425,"mtime":1611927196000,"results":"9","hashOfConfig":"8"},{"size":14108,"mtime":1612961096000,"results":"10","hashOfConfig":"8"},{"size":1025,"mtime":1612960851000,"results":"11","hashOfConfig":"8"},{"size":10736,"mtime":1612959815000,"results":"12","hashOfConfig":"8"},{"size":13365,"mtime":1612956066000,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"asqc5z",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"25","usedDeprecatedRules":"16"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx",[],["28","29"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx",["30","31","32"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts",["33","34","35"],"import { Howl, Howler } from \"howler\"\nimport { soundSources } from \"./soundsources\"\nimport { keys } from \"./App\"\nimport { SSL_OP_NO_QUERY_MTU } from \"constants\";\n\nconst chordOptions = [\"G\",\"A\",\"B\",\"C\",\"D\",\"E\"];\n\nconst sequenceLength = 32;\nconst FXLength = 7000;\n\nwindow.onload = () => {\n  masterSeq.playing = true;\n  masterSeq.restart();\n}\n\n// MasterSeq holds track of the current sequencer position\nclass MasterSeq {\n  bpm: number;\n  startOfSequence: number;\n  currentSequencePos: number;\n  nextSequencePos: number;\n  currentChord: string;\n  barsPlayed: number;\n  playing: boolean;\n  FXTimer: number;\n\n  constructor() {\n    this.bpm = 0;\n    this.startOfSequence = performance.now();\n    this.currentSequencePos = 0;\n    this.nextSequencePos = 0;\n    this.currentChord = \"\";\n    this.barsPlayed = 0;\n    this.playing = false;\n    this.FXTimer = -FXLength;\n  }\n\n  advanceSequence(trackState : any) {\n    if (this.playing) {\n      this.calcSequencePos();\n      if (this.currentSequencePos >= 32) {\n        this.barsPlayed++;\n        if (this.barsPlayed % 2 === 0){\n          newRandomChord();\n        }\n        this.restart();\n      }\n\n      if (this.currentSequencePos === this.nextSequencePos) {\n        soundSources.forEach((track: any) => {\n          if (track.kind === \"inst\" || track.kind === \"drum\")\n          track.sequencer.playCurrentSequencePos();\n        });\n\n        this.nextSequencePos++;\n      }\n    }\n\n    if (this.FXTimer < performance.now() - FXLength){\n      this.FXTimer = performance.now();\n      soundSources.forEach((track : any, index : number)=>{\n        if (track.kind === \"fx\"){\n          if (!trackState[keys.disabledKey + index]){\n            track.sequencer.sounds[0].howl.play()\n          }\n        }\n      })\n    }\n  }\n\n  calcSequencePos() {\n    let sixteenth = (60 / this.bpm / 4) * 1000;\n    let timePassed = performance.now() - this.startOfSequence;\n    this.currentSequencePos = Math.floor(timePassed / sixteenth);\n  }\n\n  restart() {\n    this.startOfSequence = performance.now();\n    this.currentSequencePos = 0;\n    this.nextSequencePos = 0;\n  }\n}\nconst masterSeq = new MasterSeq\n\n\nclass Sequencer {\n  disabled: boolean;\n  sounds: any[];\n  currentSequence: number[];\n  currentSoundIndex: number;\n  activity: number;\n  noteAmt: number;\n  patterns: any;\n  tonal : boolean;\n  maxSoundsInSequence: number;\n  minSoundsInSequence: number;\n\n  constructor(\n    sounds: any[],\n    activity: number,\n    disabled: boolean,\n    patterns: any,\n    tonal: boolean,\n    maxSoundsInSequence: number,\n    minSoundsInSequence: number,\n  ) {\n    this.sounds = sounds;\n    this.disabled = disabled;\n    this.currentSequence = [];\n    this.activity = activity;\n    this.noteAmt = 0;\n    this.patterns = patterns;\n    this.tonal = tonal;\n    this.currentSoundIndex = 0;\n    this.maxSoundsInSequence = maxSoundsInSequence\n    this.minSoundsInSequence = minSoundsInSequence\n\n    this.build();\n  }\n\n  calcAmountOfNotes() {\n    this.noteAmt =\n      this.minSoundsInSequence +\n      Math.floor((this.activity / 100) * this.maxSoundsInSequence);\n  }\n\n  build() {\n    if (this.patterns) {\n\n    } else {\n      this.calcAmountOfNotes();\n      this.currentSequence = [];\n      let possibleIndexes = [];\n      for (let i = 0; i < sequenceLength; i++) {\n        this.currentSequence.push(NaN);\n        possibleIndexes.push(i);\n      }\n      for (let i = 0; i < this.noteAmt; i++) {\n        let newSeqIndex =\n          possibleIndexes[Math.floor(Math.random() * sequenceLength)];\n        let newSoundIndex = getNextSoundIndex(this.sounds, masterSeq.currentChord);\n        this.currentSequence[newSeqIndex] = newSoundIndex;\n        possibleIndexes.splice(newSeqIndex, 1);\n      }\n    }\n  }\n\n  playCurrentSequencePos(){\n      if (!isNaN(this.currentSequence[masterSeq.currentSequencePos])) {\n        //this.sounds[this.currentSoundIndex].howl.stop();\n        if (!this.disabled) {\n          this.sounds[this.currentSequence[masterSeq.currentSequencePos]].howl.play();\n          this.currentSoundIndex = this.currentSequence[masterSeq.currentSequencePos];\n        }\n      }  \n  }\n\n  mutate() {}\n\n  updateChords() {\n    if (this.tonal) {\n      this.currentSequence.forEach((seqItem: number, seqIndex: number) => {\n        if (!isNaN(seqItem)) {\n          if (!this.sounds[seqItem].chords.includes(masterSeq.currentChord)) {\n            this.currentSequence[seqIndex] = getNextSoundIndex(\n              this.sounds,\n              masterSeq.currentChord\n            );\n          }\n        }\n      });\n    }\n  }\n\n  updateActivity(){\n    this.calcAmountOfNotes();\n    let currentSequenceNoteIndices : number[] = [];\n    let currentSequenceEmptyIndices : number[] = [];\n    let editIndex : number;\n    let noteDifference : number;\n\n    this.currentSequence.forEach((seqItem : number, index: number) => {\n        if (!isNaN(seqItem)){\n            currentSequenceNoteIndices.push(index)\n        }   else {\n            currentSequenceEmptyIndices.push(index)\n        }\n    })\n\n    noteDifference = this.noteAmt - currentSequenceNoteIndices.length\n    if (noteDifference < 0){\n        for (let i = 0; i > noteDifference; i--){\n            editIndex = Math.floor(Math.random() * currentSequenceNoteIndices.length);\n            this.currentSequence[currentSequenceNoteIndices[editIndex]] = NaN;\n            currentSequenceNoteIndices.splice(editIndex, 1)\n        }\n    } else if (noteDifference > 0){\n        for (let i = 0; i < noteDifference; i++){\n            editIndex = Math.floor(Math.random() * currentSequenceEmptyIndices.length);\n            this.currentSequence[currentSequenceEmptyIndices[editIndex]] = getNextSoundIndex(this.sounds, masterSeq.currentChord);\n            currentSequenceEmptyIndices.splice(editIndex, 1)\n        }\n    }\n  }\n}\n\nclass Sound {\n  howl: any;\n  chords: any;\n\n  constructor(url: string, baseVolume: number, initVolume: number, chords: string[]) {\n    this.howl = new Howl({\n      src: [url],\n      volume: baseVolume * (initVolume / 100)\n    })\n    this.chords = chords;\n  }\n}\n\n/*  for each track, initsoundPlayer loads every sample into a new howl, \n    together with the chords that particular sound can be played on it.\n    All these sounds are then pushed into a sequencer object, which controls the playback\n    \n    soundSources [\n        sequencer :\n            sounds: [{\n                howl: *ACTUAL SOUND*\n                chords [\"Array of chords it can be played on\"]\n            ]}\n    ]  \n*/\n\nexport function initSoundPlayer(state: any) {\n  Howler.volume(2);\n\n  masterSeq.bpm = state.bpm;\n  masterSeq.currentChord = state.currentChord;\n\n  soundSources.forEach((track: any, index: number) => {\n    let soundsArr: any[] = [];\n    switch (track.kind) {\n      case \"inst\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(sample.sampleSource, track.baseVolume, track.initVolume, sample.chords)\n          );\n        });\n        track.sequencer = new Sequencer(\n          soundsArr,\n          state[keys.actKey + index],\n          state[keys.disabledKey + index],\n          false,\n          true,\n          track.maxSoundsInSequence,\n          track.minSoundsInSequence\n        );\n        break;\n\n      case \"drum\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(sample.sampleSource, track.baseVolume, track.initVolume, sample.chords)\n          );\n        });\n        track.sequencer = new Sequencer(\n          soundsArr,\n          100,\n          state[keys.disabledKey + index].disabled,\n          track.patterns,\n          false,\n          track.maxSoundsInSequence,\n          track.minSoundsInSequence\n        );\n        track.sequencer.currentSequence = soundSources[index].patterns[soundSources[index].initPattern];\n        break;\n\n        case \"fx\":\n          track.sampleLoader.forEach((sample: any) => {\n            soundsArr.push(\n              new Sound(sample.sampleSource, track.baseVolume, track.initVolume, sample.chords)\n            );\n          });\n          track.sequencer = new Sequencer(\n            soundsArr,\n            100,\n            state[keys.disabledKey + index].disabled,\n            false,\n            false,\n            track.maxSoundsInSequence,\n            track.minSoundsInSequence\n          );\n          break;\n          \n    }\n    \n  });\n}\n\n\nexport function updateSoundPlayer(trackState : any) {\n  masterSeq.advanceSequence(trackState);\n  return (masterSeq.currentChord);\n}\n\nexport function setTrackVolume(volume: number, index: number) {\n  soundSources[index].sequencer.sounds.forEach((sound: any) => {\n    sound.howl.volume(\n      (volume / 100) * soundSources[index].baseVolume\n    );\n  });\n}\n\nexport function updateTrackActivity(activity: number, index: number) {\n  soundSources[index].sequencer.activity = activity;\n  soundSources[index].sequencer.updateActivity();\n}\n\nexport function setTrackDisable(disabled : boolean, index: number) {\n  soundSources[index].sequencer.disabled = disabled;\n  if (disabled) {\n    stopAllSounds(index);\n  }\n  if (!disabled && soundSources[index].kind === \"fx\"){\n    soundSources[index].sequencer.sounds[0].howl.play()\n  }\n}\n\nfunction stopAllSounds(index: number) {\n  soundSources[index].sequencer.sounds.forEach((sound: any) => {\n    sound.howl.stop();\n  });\n}\n\nfunction getRandomIntButNotThisOne(range: number, current: number) {\n  let out = Math.floor(Math.random() * range);\n  if (out === current) {\n    out = getRandomIntButNotThisOne(range, out);\n  }\n  return out;\n}\n\nfunction getNextSoundIndex(sounds: object[], currentChord: string) {\n  let newSoundIndex: number;\n  let newSoundOptions: number[] = [];\n  sounds.forEach((sound: any, index: number) => {\n    if (sound.chords.includes(currentChord)) {\n      newSoundOptions.push(index);\n    }\n  });\n  newSoundIndex =\n    newSoundOptions[Math.floor(Math.random() * newSoundOptions.length)];\n\n  return newSoundIndex;\n}\n\nexport function updateBPM(bpm: number, rhythmic: boolean) {\n  let timePassed = performance.now() - masterSeq.startOfSequence;\n  if (masterSeq.bpm !== bpm){\n    let rhythmScale = masterSeq.bpm / bpm;\n    masterSeq.startOfSequence = performance.now() - timePassed * rhythmScale;\n    masterSeq.bpm = bpm;\n  }\n}\n\nexport function updateCurrentSequenceChords(currentChord: string) {\n  masterSeq.currentChord = currentChord;\n  soundSources.forEach((track: any, index: any) => {\n    if (track.kind === \"inst\"){\n      track.sequencer.updateChords();\n    }\n  });\n}\n\nexport function updatePattern(value: number, index: number){\n  soundSources[index].sequencer.currentSequence = soundSources[index].patterns[value - 1];\n}\n\nfunction newRandomChord() {\n  updateCurrentSequenceChords(chordOptions[Math.floor(Math.random() * 6)]);\n}\n\n\n\n\n\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts",[],{"ruleId":"36","replacedBy":"37"},{"ruleId":"38","replacedBy":"39"},{"ruleId":"40","severity":1,"message":"41","line":167,"column":55,"nodeType":"42","messageId":"43","endLine":167,"endColumn":57},{"ruleId":"40","severity":1,"message":"41","line":250,"column":55,"nodeType":"42","messageId":"43","endLine":250,"endColumn":57},{"ruleId":"40","severity":1,"message":"41","line":292,"column":55,"nodeType":"42","messageId":"43","endLine":292,"endColumn":57},{"ruleId":"44","severity":1,"message":"45","line":4,"column":10,"nodeType":"46","messageId":"47","endLine":4,"endColumn":29},{"ruleId":"48","severity":1,"message":"49","line":83,"column":19,"nodeType":"50","messageId":"51","endLine":83,"endColumn":32,"fix":"52"},{"ruleId":"44","severity":1,"message":"53","line":337,"column":11,"nodeType":"46","messageId":"47","endLine":337,"endColumn":36},"no-native-reassign",["54"],"no-negated-in-lhs",["55"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","@typescript-eslint/no-unused-vars","'SSL_OP_NO_QUERY_MTU' is defined but never used.","Identifier","unusedVar","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"56","text":"57"},"'getRandomIntButNotThisOne' is defined but never used.","no-global-assign","no-unsafe-negation",[2116,2116],"()"]