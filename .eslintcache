[{"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx":"1","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts":"2","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx":"3","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts":"4","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts":"5","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts":"6"},{"size":502,"mtime":1612961605000,"results":"7","hashOfConfig":"8"},{"size":425,"mtime":1611927196000,"results":"9","hashOfConfig":"8"},{"size":16479,"mtime":1613043881000,"results":"10","hashOfConfig":"8"},{"size":1025,"mtime":1612961605000,"results":"11","hashOfConfig":"8"},{"size":8830,"mtime":1613042856000,"results":"12","hashOfConfig":"8"},{"size":15112,"mtime":1613040002000,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"asqc5z",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"16"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx",[],["28","29"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/reportWebVitals.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx",["30","31","32"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts",["33","34","35"],"import { Howl, Howler } from \"howler\"\nimport { soundSources } from \"./soundsources\"\nimport { keys, seqLength } from \"./App\"\nimport { SSL_OP_NO_QUERY_MTU } from \"constants\";\n\nconst chordOptions = [\"G\",\"A\",\"B\",\"C\",\"D\",\"E\"];\n\nclass Sequencer {\n  disabled: boolean;\n  sounds: any[];\n  currentSequence: number[];\n  currentSoundIndex: number;\n  activity: number;\n  noteAmt: number;\n  patterns: any;\n  tonal : boolean;\n  maxSoundsInSequence: number;\n  minSoundsInSequence: number;\n\n  constructor(\n    sounds: any[],\n    activity: number,\n    disabled: boolean,\n    patterns: any,\n    tonal: boolean,\n    maxSoundsInSequence: number,\n    minSoundsInSequence: number,\n    currentChord: string\n  ) {\n    this.sounds = sounds;\n    this.disabled = disabled;\n    this.currentSequence = [];\n    this.activity = activity;\n    this.noteAmt = 0;\n    this.patterns = patterns;\n    this.tonal = tonal;\n    this.currentSoundIndex = 0;\n    this.maxSoundsInSequence = maxSoundsInSequence\n    this.minSoundsInSequence = minSoundsInSequence\n\n    this.build(currentChord);\n  }\n\n  calcAmountOfNotes() {\n    this.noteAmt =\n      this.minSoundsInSequence +\n      Math.floor((this.activity / 100) * this.maxSoundsInSequence);\n  }\n\n  build(currentChord : string) {\n    if (this.patterns) {\n\n    } else {\n      this.calcAmountOfNotes();\n      this.currentSequence = [];\n      let possibleIndexes = [];\n      for (let i = 0; i < seqLength; i++) {\n        this.currentSequence.push(NaN);\n        possibleIndexes.push(i);\n      }\n      for (let i = 0; i < this.noteAmt; i++) {\n        let newSeqIndex =\n          possibleIndexes[Math.floor(Math.random() * seqLength)];\n        let newSoundIndex = getNextSoundIndex(this.sounds, currentChord);\n        this.currentSequence[newSeqIndex] = newSoundIndex;\n        possibleIndexes.splice(newSeqIndex, 1);\n      }\n    }\n  }\n\n  playSeqPosition(position : number){\n      if (!isNaN(this.currentSequence[position])) {\n        //this.sounds[this.currentSoundIndex].howl.stop();\n        if (!this.disabled) {\n          this.sounds[this.currentSequence[position]].howl.play();\n          this.currentSoundIndex = this.currentSequence[position];\n        }\n      }  \n  }\n\n  mutate() {}\n\n  updateChords(currentChord : string) {\n    if (this.tonal) {\n      this.currentSequence.forEach((seqItem: number, seqIndex: number) => {\n        if (!isNaN(seqItem)) {\n          if (!this.sounds[seqItem].chords.includes(currentChord)) {\n            this.currentSequence[seqIndex] = getNextSoundIndex(\n              this.sounds,\n              currentChord\n            );\n          }\n        }\n      });\n    }\n  }\n\n  updateActivity(currentChord : string){\n    this.calcAmountOfNotes();\n    let currentSequenceNoteIndices : number[] = [];\n    let currentSequenceEmptyIndices : number[] = [];\n    let editIndex : number;\n    let noteDifference : number;\n\n    this.currentSequence.forEach((seqItem : number, index: number) => {\n        if (!isNaN(seqItem)){\n            currentSequenceNoteIndices.push(index)\n        }   else {\n            currentSequenceEmptyIndices.push(index)\n        }\n    })\n\n    noteDifference = this.noteAmt - currentSequenceNoteIndices.length\n    if (noteDifference < 0){\n        for (let i = 0; i > noteDifference; i--){\n            editIndex = Math.floor(Math.random() * currentSequenceNoteIndices.length);\n            this.currentSequence[currentSequenceNoteIndices[editIndex]] = NaN;\n            currentSequenceNoteIndices.splice(editIndex, 1)\n        }\n    } else if (noteDifference > 0){\n        for (let i = 0; i < noteDifference; i++){\n            editIndex = Math.floor(Math.random() * currentSequenceEmptyIndices.length);\n            this.currentSequence[currentSequenceEmptyIndices[editIndex]] = getNextSoundIndex(this.sounds, currentChord);\n            currentSequenceEmptyIndices.splice(editIndex, 1)\n        }\n    }\n  }\n}\n\nclass Sound {\n  howl: any;\n  chords: any;\n\n  constructor(url: string, baseVolume: number, initVolume: number, chords: string[]) {\n    this.howl = new Howl({\n      src: [url],\n      volume: baseVolume * (initVolume / 100)\n    })\n    this.chords = chords;\n  }\n}\n\n/*  for each track, initsoundPlayer loads every sample into a new howl, \n    together with the chords that particular sound can be played on it.\n    All these sounds are then pushed into a sequencer object, which controls the playback\n    \n    soundSources [\n        sequencer :\n            sounds: [{\n                howl: *ACTUAL SOUND*\n                chords [\"Array of chords it can be played on\"]\n            ]}\n    ]  \n*/\n\nexport function initSoundPlayer(state: any) {\n  Howler.volume(2);\n\n  soundSources.forEach((track: any, index: number) => {\n    let soundsArr: any[] = [];\n    switch (track.kind) {\n      case \"inst\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(sample.sampleSource, track.baseVolume, track.initVolume, sample.chords)\n          );\n        });\n        track.sequencer = new Sequencer(\n          soundsArr,\n          state[keys.actKey + index],\n          state[keys.disabledKey + index],\n          false,\n          true,\n          track.maxSoundsInSequence,\n          track.minSoundsInSequence,\n          state.currentChord\n        );\n        break;\n\n      case \"drum\":\n        track.sampleLoader.forEach((sample: any) => {\n          soundsArr.push(\n            new Sound(sample.sampleSource, track.baseVolume, track.initVolume, sample.chords)\n          );\n        });\n        track.sequencer = new Sequencer(\n          soundsArr,\n          100,\n          state[keys.disabledKey + index].disabled,\n          track.patterns,\n          false,\n          track.maxSoundsInSequence,\n          track.minSoundsInSequence,\n          state.currentChord\n        );\n        track.sequencer.currentSequence = soundSources[index].patterns[soundSources[index].initPattern];\n        break;\n\n        case \"fx\":\n          track.sampleLoader.forEach((sample: any) => {\n            soundsArr.push(\n              new Sound(sample.sampleSource, track.baseVolume, track.initVolume, sample.chords)\n            );\n          });\n          track.sequencer = new Sequencer(\n            soundsArr,\n            100,\n            state[keys.disabledKey + index].disabled,\n            false,\n            false,\n            track.maxSoundsInSequence,\n            track.minSoundsInSequence,\n            state.currentChord\n          );\n          break;     \n    }    \n  });\n}\n\n\nexport function setTrackVolume(volume: number, index: number) {\n  soundSources[index].sequencer.sounds.forEach((sound: any) => {\n    sound.howl.volume(\n      (volume / 100) * soundSources[index].baseVolume\n    );\n  });\n}\n\nexport function updateTrackActivity(activity: number, index: number, currentChord: string) {\n  soundSources[index].sequencer.activity = activity;\n  soundSources[index].sequencer.updateActivity(currentChord);\n}\n\nexport function setTrackDisable(disabled : boolean, index: number) {\n  soundSources[index].sequencer.disabled = disabled;\n  if (disabled) {\n    stopAllSounds(index);\n  }\n  if (!disabled && soundSources[index].kind === \"fx\"){\n    soundSources[index].sequencer.sounds[0].howl.play()\n  }\n}\n\nfunction stopAllSounds(index: number) {\n  soundSources[index].sequencer.sounds.forEach((sound: any) => {\n    sound.howl.stop();\n  });\n}\n\nfunction getRandomIntButNotThisOne(range: number, current: number) {\n  let out = Math.floor(Math.random() * range);\n  if (out === current) {\n    out = getRandomIntButNotThisOne(range, out);\n  }\n  return out;\n}\n\nfunction getNextSoundIndex(sounds: object[], currentChord: string) {\n  let newSoundIndex: number;\n  let newSoundOptions: number[] = [];\n  sounds.forEach((sound: any, index: number) => {\n    if (sound.chords.includes(currentChord)) {\n      newSoundOptions.push(index);\n    }\n  });\n  newSoundIndex =\n    newSoundOptions[Math.floor(Math.random() * newSoundOptions.length)];\n\n  return newSoundIndex;\n}\n\nexport function updateCurrentSequenceChords(currentChord: string) {\n  soundSources.forEach((track: any, index: any) => {\n    if (track.kind === \"inst\"){\n      track.sequencer.updateChords(currentChord);\n    }\n  });\n}\n\nexport function playSequencers(position: number){\n  soundSources.forEach((track: any, index: any) => {\n    if (track.kind === \"inst\" || track.kind === \"drum\"){\n      track.sequencer.playSeqPosition(position);\n    }\n  });\n}\n\nexport function playFX(){\n  soundSources.forEach((track: any, index: any) => {\n    if (track.kind === \"fx\"){\n      if (!track.sequencer.disabled){\n      track.sequencer.sounds[0].howl.play();\n      }\n    }\n  });\n}\n\nexport function updatePattern(value: number, index: number){\n  soundSources[index].sequencer.currentSequence = soundSources[index].patterns[value - 1];\n}\n\nfunction newRandomChord() {\n  updateCurrentSequenceChords(chordOptions[Math.floor(Math.random() * 6)]);\n}\n\n\n\n\n\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts",[],{"ruleId":"36","replacedBy":"37"},{"ruleId":"38","replacedBy":"39"},{"ruleId":"40","severity":1,"message":"41","line":245,"column":55,"nodeType":"42","messageId":"43","endLine":245,"endColumn":57},{"ruleId":"40","severity":1,"message":"41","line":327,"column":55,"nodeType":"42","messageId":"43","endLine":327,"endColumn":57},{"ruleId":"40","severity":1,"message":"41","line":375,"column":55,"nodeType":"42","messageId":"43","endLine":375,"endColumn":57},{"ruleId":"44","severity":1,"message":"45","line":4,"column":10,"nodeType":"46","messageId":"47","endLine":4,"endColumn":29},{"ruleId":"44","severity":1,"message":"48","line":253,"column":11,"nodeType":"46","messageId":"47","endLine":253,"endColumn":36},{"ruleId":"44","severity":1,"message":"49","line":302,"column":10,"nodeType":"46","messageId":"47","endLine":302,"endColumn":24},"no-native-reassign",["50"],"no-negated-in-lhs",["51"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","@typescript-eslint/no-unused-vars","'SSL_OP_NO_QUERY_MTU' is defined but never used.","Identifier","unusedVar","'getRandomIntButNotThisOne' is defined but never used.","'newRandomChord' is defined but never used.","no-global-assign","no-unsafe-negation"]