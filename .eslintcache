[{"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx":"1","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx":"2","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts":"3","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts":"4","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts":"5","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/visuals.ts":"6","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/chordcontainer.tsx":"7","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/loadingscreen.tsx":"8","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/mobileui.tsx":"9","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/helpscreen.tsx":"10"},{"size":222,"mtime":1623276419000,"results":"11","hashOfConfig":"12"},{"size":34064,"mtime":1623672219000,"results":"13","hashOfConfig":"12"},{"size":1025,"mtime":1613054079000,"results":"14","hashOfConfig":"12"},{"size":6700,"mtime":1614793710000,"results":"15","hashOfConfig":"12"},{"size":21529,"mtime":1614793102000,"results":"16","hashOfConfig":"12"},{"size":8972,"mtime":1623671952000,"results":"17","hashOfConfig":"12"},{"size":2800,"mtime":1623672610000,"results":"18","hashOfConfig":"12"},{"size":1765,"mtime":1623276419000,"results":"19","hashOfConfig":"12"},{"size":10314,"mtime":1623671894000,"results":"20","hashOfConfig":"12"},{"size":4522,"mtime":1623671630000,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"asqc5z",{"filePath":"25","messages":"26","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"24"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"24"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/index.tsx",[],["45","46"],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/App.tsx",["47","48","49","50","51","52"],"import React from \"react\";\nimport { updateDrift } from \"./drift\";\nimport {\n  initSoundPlayer,\n  setTrackVolume,\n  updateSeqChords,\n  playFX,\n  stopAllSounds,\n  randomMutation,\n  buildFromActivity,\n  buildFromPattern,\n  updateActivity,\n} from \"./soundplayer\";\n\nimport { MobileUI } from \"./mobileui\";\nimport HelpScreen from \"./helpscreen\";\nimport { soundSources } from \"./soundsources\";\nimport ChordContainer from \"./chordcontainer\";\nimport LoadingScreen from \"./loadingscreen\";\nimport \"./App.css\";\nimport {\n  updateGraphics,\n  initGraphics,\n  ripple,\n  colors,\n  screenResize,\n} from \"./visuals\";\nimport minus from \"./img/minus.svg\";\nimport plus from \"./img/plus.svg\";\nimport volumeOn from \"./img/volumeon.svg\";\nimport volumeOff from \"./img/volumeoff.svg\";\nimport turtle from \"./img/turtle.svg\";\nimport rabbit from \"./img/rabbit.svg\";\nimport rain from \"./img/rain.svg\";\nimport trees from \"./img/trees.svg\";\nimport gramophone from \"./img/gramophone.svg\";\nimport play from \"./img/play.svg\";\nimport pause from \"./img/pause.svg\";\n\n// keys for dymaically creating and accessing state properties\nexport const keys = {\n  volKey: \"volume\",\n  actKey: \"activity\",\n  volDriftKey: \"volDriftVelocity\",\n  actDriftKey: \"actDriftVelocity\",\n  disabledKey: \"disabled\",\n  patKey: \"pattern\",\n  seqKey: \"currentSequence\",\n  showTrack: \"showTrack\",\n  nowPlaying: \"nowPlaying\",\n};\nexport const seqLength = 32;\nexport const chords = [\n    {\n      value: \"G\",\n      name: \"G\",\n    },\n    {\n      value: \"A\",\n      name: \"Am\",\n    },\n    {\n      value: \"B\",\n      name: \"Bm\",\n    },\n    {\n      value: \"C\",\n      name: \"C\",\n    },\n    {\n      value: \"D\",\n      name: \"D\",\n    },\n    {\n      value: \"E\",\n      name: \"Em\",\n    },\n  ],\n  chordChangeOptions = [2, 4, 8],\n  drumChangeOptions = [2, 4, 8, 16],\n  tempoChangeOptions = [8, 16],\n  FXLength = 6000,\n  bpmVariance = 8,\n  fxIcons = [gramophone, rain, trees];\nexport const mobile = 650,\n  maxBpm = 150,\n  minBpm = 50;\n\nexport let amountOfSoundsLoaded = 0;\nexport const amountOfSounds = soundSources.reduce(\n  (total: number, track: any) => {\n    return total + track.sampleLoader.length;\n  },\n  0\n);\n\nexport const increaseLoadedSounds = () => {\n  amountOfSoundsLoaded++;\n};\n\n// initialize state from soundsources object, create properties for every track\nconst initState: any = {};\ninitializeState();\n\nexport class App extends React.Component<any, any> {\n  constructor(props: any) {\n    super(props);\n    this.state = { ...initState };\n\n    this.appLoop = this.appLoop.bind(this);\n    this.updateMasterSeq = this.updateMasterSeq.bind(this);\n    this.handleVolumeChange = this.handleVolumeChange.bind(this);\n    this.handleActivityChange = this.handleActivityChange.bind(this);\n    this.handleDriftToggle = this.handleDriftToggle.bind(this);\n    this.handleDisableToggle = this.handleDisableToggle.bind(this);\n    this.handleChordUIToggle = this.handleChordUIToggle.bind(this);\n    this.handleFxUIToggle = this.handleFxUIToggle.bind(this);\n    this.handlePatternChange = this.handlePatternChange.bind(this);\n    this.handleBpmChange = this.handleBpmChange.bind(this);\n    this.handleChordClick = this.handleChordClick.bind(this);\n    this.handleChordChange = this.handleChordChange.bind(this);\n    this.handlePlayingToggle = this.handlePlayingToggle.bind(this);\n    this.startApp = this.startApp.bind(this);\n    this.animateLoadingScreen = this.animateLoadingScreen.bind(this);\n    this.loadChecker = this.loadChecker.bind(this);\n    this.handleResize = this.handleResize.bind(this);\n    this.handleTrackSelect = this.handleTrackSelect.bind(this);\n    this.handleVolumeClick = this.handleVolumeClick.bind(this);\n    this.handleActivityClick = this.handleActivityClick.bind(this);\n    this.handlePatternClick = this.handlePatternClick.bind(this);\n    this.toggleHelp = this.toggleHelp.bind(this);\n  }\n\n  startApp() {\n    this.setState({ appStarted: true }, () => {\n      let sixteenth = (60 / this.state.bpm / 4) * 1000;\n      setTimeout(this.updateMasterSeq, sixteenth);\n      setTimeout(this.appLoop, 100);\n      setTimeout(() => this.setState({ hideOpeningScreen: true }), 500);\n    });\n  }\n\n  toggleHelp() {\n    this.setState({ showHelp: !this.state.showHelp });\n  }\n\n  handleTrackSelect(index: number, selected: boolean) {\n    let newSelectState = [...this.state.trackSelected];\n    newSelectState[index] = selected;\n    this.setState({ trackSelected: newSelectState });\n  }\n\n  animateLoadingScreen() {\n    if (!this.state.loaded) {\n      let newPoints = [...this.state.loadingAnimPoints];\n      newPoints.push(\".\");\n      if (newPoints.length > 4) {\n        newPoints.length = 0;\n      }\n      this.setState({ loadingAnimPoints: newPoints });\n      setTimeout(this.animateLoadingScreen, 500);\n    }\n  }\n\n  handleVolumeChange(value: any, index: number) {\n    let newVolumeState: any = {};\n    newVolumeState[keys.volKey + index] = parseFloat(value);\n    this.setState({ ...newVolumeState }, () =>\n      setTrackVolume(this.state[keys.volKey + index], index)\n    );\n  }\n\n  handleVolumeClick(amt: number, index: number) {\n    let newVol = this.state[keys.volKey + index] + amt;\n    newVol = Math.min(Math.max(newVol, 0), 100);\n    this.handleVolumeChange(newVol, index);\n  }\n\n  handleActivityChange(value: any, index: number) {\n    let newActivityState: any = {};\n    newActivityState[keys.actKey + index] = parseFloat(value);\n    this.setState({ ...newActivityState }, () => {\n      let newSeqState: any = {};\n      newSeqState[keys.seqKey + index] = updateActivity(\n        this.state.currentChord,\n        soundSources[index].sounds,\n        this.state[keys.actKey + index],\n        soundSources[index].minSoundsInSequence,\n        soundSources[index].maxSoundsInSequence,\n        this.state[keys.seqKey + index]\n      );\n      this.setState({ ...newSeqState });\n    });\n  }\n\n  handleActivityClick(amt: number, index: number) {\n    let newAct = this.state[keys.actKey + index] + amt;\n    newAct = Math.min(Math.max(newAct, 0), 100);\n    this.handleActivityChange(newAct, index);\n  }\n\n  handleDriftToggle() {\n    let newDriftState: any = {};\n    newDriftState.drifting = !this.state.drifting;\n    newDriftState.masterSeq = this.state.masterSeq;\n    newDriftState.masterSeq.newDrumSeq =\n      this.state.masterSeq.newDrumSeq + randomArrEntry(drumChangeOptions);\n    this.setState({ ...newDriftState });\n  }\n\n  handleDisableToggle(value: boolean, index: number) {\n    let newDisabledState: any = {};\n    newDisabledState[keys.disabledKey + index] = !value;\n    if (!value) {\n      stopAllSounds(index);\n    }\n    this.setState({ ...newDisabledState });\n  }\n\n  handleChordUIToggle() {\n    let newUIState: any = {};\n    newUIState.showChordUI = !this.state.showChordUI;\n    this.setState({ ...newUIState });\n  }\n\n  handleFxUIToggle() {\n    let newUIState: any = {};\n    newUIState.showFxUI = !this.state.showFxUI;\n    this.setState({ ...newUIState });\n  }\n\n  handleChordClick(index: number, amt: number) {\n    let newSeq = { ...this.state.masterSeq };\n    newSeq.progression[index] += amt;\n    if (newSeq.progression[index] >= chords.length) {\n      newSeq.progression[index] = 0;\n    }\n    if (newSeq.progression[index] < 0) {\n      newSeq.progression[index] = chords.length - 1;\n    }\n    this.setState({ ...newSeq }, () => {\n      if (newSeq.currentBarInProgression === index) {\n        this.handleChordChange(chords[newSeq.progression[index]].value);\n      }\n    });\n  }\n\n  handleChordChange(chord: string) {\n    if (chord !== this.state.currentChord) {\n      this.setState({ currentChord: chord }, () => {\n        soundSources.forEach((track: any, index: any) => {\n          if (track.kind === \"inst\") {\n            let newSeqState: any = {};\n            newSeqState[keys.seqKey + index] = updateSeqChords(\n              this.state.currentChord,\n              soundSources[index].sounds,\n              this.state[keys.seqKey + index]\n            );\n            this.setState({ ...newSeqState });\n          }\n        });\n      });\n    }\n  }\n\n  handleBpmChange(newBpm: number) {\n    this.setState({ bpm: newBpm });\n  }\n\n  handlePlayingToggle() {\n    this.setState({ playing: !this.state.playing }, () => {\n      if (!this.state.playing) {\n        soundSources.forEach((track: any, index: number) => {\n          stopAllSounds(index);\n        });\n      }\n    });\n  }\n\n  handlePatternChange(value: number, index: number) {\n    let newPatternState: any = {};\n    newPatternState[keys.patKey + index] = value;\n    this.setState({ ...newPatternState }, () => {\n      let newSeq: any = {};\n      newSeq[keys.seqKey + index] = buildFromPattern(\n        value - 1,\n        soundSources[index].patterns,\n        soundSources[index].sounds\n      );\n      this.setState({ ...newSeq });\n    });\n  }\n\n  handlePatternClick(amt: number, index: number) {\n    let newPat = this.state[keys.patKey + index] + amt;\n    newPat = Math.min(Math.max(newPat, 1), soundSources[index].patterns.length);\n    this.handlePatternChange(newPat, index);\n  }\n\n  updateMasterSeq() {\n    let sixteenth = (60 / this.state.bpm / 4) * 1000;\n    setTimeout(this.updateMasterSeq, sixteenth);\n\n    let { masterSeq, ...newState }: any = { ...this.state };\n\n    newState.lastPlayTime = performance.now();\n\n    if (this.state.playing) {\n      if (this.state.drifting) {\n        //check if track properties should 'drift'\n        soundSources.forEach((track: any, index: number) => {\n          let newVolumeObj = updateDrift(\n            newState[keys.volKey + index],\n            newState[keys.volDriftKey + index],\n            100,\n            0\n          );\n          newState[keys.volDriftKey + index] = newVolumeObj.velocity;\n          newState[keys.volKey + index] = newVolumeObj.value;\n          setTrackVolume(newState[keys.volKey + index], index);\n\n          if (track.kind === \"inst\") {\n            let newActivityObj = updateDrift(\n              newState[keys.actKey + index],\n              newState[keys.actDriftKey + index],\n              100,\n              0\n            );\n            newState[keys.actDriftKey + index] = newActivityObj.velocity;\n            newState[keys.actKey + index] = newActivityObj.value;\n            newState[keys.seqKey + index] = updateActivity(\n              newState.currentChord,\n              soundSources[index].sounds,\n              newState[keys.actKey + index],\n              soundSources[index].minSoundsInSequence,\n              soundSources[index].maxSoundsInSequence,\n              newState[keys.seqKey + index]\n            );\n          }\n        });\n      }\n\n      // play sounds\n      let whosPlaying = playSequencers(this.state);\n      soundSources.forEach((track: any, index: any) => {\n        if (track.kind === \"inst\" || track.kind === \"drum\") {\n          newState[keys.nowPlaying + index] =\n            whosPlaying[keys.nowPlaying + index];\n        }\n      });\n\n      masterSeq.currentSequencePos++;\n      if (masterSeq.currentSequencePos >= seqLength) {\n        masterSeq.currentSequencePos = 0;\n        masterSeq.barsPlayed++;\n\n        //handle cycling through the chord progression\n        masterSeq.currentBarInProgression++;\n        if (masterSeq.currentBarInProgression > 3) {\n          masterSeq.currentBarInProgression = 0;\n        }\n        if (\n          chords[masterSeq.progression[masterSeq.currentBarInProgression]]\n            .value !== newState.currentChord\n        ) {\n          newState.currentChord =\n            chords[\n              masterSeq.progression[masterSeq.currentBarInProgression]\n            ].value;\n          console.log(newState);\n          soundSources.forEach((track: any, index: any) => {\n            if (track.kind === \"inst\") {\n              newState[keys.seqKey + index] = updateSeqChords(\n                newState.currentChord,\n                soundSources[index].sounds,\n                newState[keys.seqKey + index]\n              );\n            }\n          });\n        }\n\n        //should the tempo randomly change?\n        if (newState.drifting) {\n          if (masterSeq.barsPlayed >= masterSeq.tempoChangeTimer) {\n            masterSeq.tempoChangeTimer =\n              masterSeq.barsPlayed + randomArrEntry(tempoChangeOptions);\n            let newBpm = newState.bpm;\n            newBpm -= bpmVariance;\n            newBpm += Math.round(bpmVariance * 2 * Math.random());\n            if (newBpm > maxBpm) {\n              newBpm = maxBpm;\n            }\n            if (newBpm < minBpm) {\n              newBpm = minBpm;\n            }\n            newState.bpm = newBpm;\n          }\n\n          // should a sequence mutate/evolve?\n          soundSources.forEach((track: any, index: number) => {\n            if (!newState[keys.disabledKey + index]) {\n              if (track.kind === \"inst\") {\n                if (Math.random() < track.mutationChance) {\n                  newState[keys.seqKey + index] = randomMutation(\n                    1,\n                    newState[keys.seqKey + index],\n                    soundSources[index].sounds,\n                    true,\n                    newState.currentChord\n                  );\n                }\n              }\n              if (track.kind === \"drum\") {\n                if (Math.random() < track.mutationChance) {\n                  newState[keys.seqKey + index] = randomMutation(\n                    1,\n                    newState[keys.seqKey + index],\n                    soundSources[index].sounds,\n                    false,\n                    newState.currentChord\n                  );\n                }\n              }\n            }\n          });\n\n          // should the drums change to a new pattern?\n          if (masterSeq.barsPlayed >= masterSeq.newDrumSeq) {\n            soundSources.forEach((track: any, index: number) => {\n              if (track.kind === \"drum\") {\n                newState[keys.patKey + index] =\n                  Math.floor(Math.random() * track.patterns.length) + 1;\n\n                newState[keys.seqKey + index] = buildFromPattern(\n                  newState[keys.patKey + index] - 1,\n                  soundSources[index].patterns,\n                  soundSources[index].sounds\n                );\n              }\n            });\n            masterSeq.newDrumSeq =\n              randomArrEntry(drumChangeOptions) + masterSeq.barsPlayed;\n          }\n\n          //should the chords randomly change?\n          if (masterSeq.barsPlayed >= masterSeq.newChord) {\n            let changeIndex = Math.floor(\n              Math.random() * masterSeq.progression.length\n            );\n            masterSeq.progression[changeIndex] = Math.floor(\n              Math.random() * chords.length\n            );\n            masterSeq.newChord =\n              randomArrEntry(chordChangeOptions) + masterSeq.barsPlayed;\n            if (masterSeq.barsPlayed % 4 === changeIndex) {\n              newState.currentChord =\n                chords[masterSeq.progression[changeIndex]].value;\n              soundSources.forEach((track: any, index: any) => {\n                if (track.kind === \"inst\") {\n                  newState[keys.seqKey + index] = updateSeqChords(\n                    newState.currentChord,\n                    soundSources[index].sounds,\n                    newState[keys.seqKey + index]\n                  );\n                }\n              });\n            }\n          }\n        }\n      }\n\n      //retrigger FX loops if necessary\n      if (!this.state.mobileUI) {\n        if (performance.now() - masterSeq.FXTimer > FXLength) {\n          playFX(this.state);\n          masterSeq.FXTimer = performance.now();\n        }\n      }\n      this.setState({ masterSeq: { ...masterSeq }, ...newState });\n    }\n  }\n\n  loadChecker() {\n    if (amountOfSounds === amountOfSoundsLoaded) {\n      this.setState({ loaded: true });\n    } else {\n      setTimeout(() => this.loadChecker(), 10);\n    }\n  }\n\n  handleResize() {\n    screenResize();\n    if (window.innerWidth < mobile && !this.state.mobileUI) {\n      this.setState({ mobileUI: true });\n    }\n    if (window.innerWidth > mobile && this.state.mobileUI) {\n      this.setState({ mobileUI: false });\n    }\n  }\n\n  // main loop\n  appLoop() {\n    updateGraphics(this.state);\n    window.requestAnimationFrame(this.appLoop);\n  }\n\n  componentDidMount() {\n    this.animateLoadingScreen();\n    initSoundPlayer();\n    initGraphics(this.state.mobileUI, this.state.hq);\n    this.loadChecker();\n\n    window.addEventListener(\"resize\", this.handleResize);\n    this.handleResize();\n\n    soundSources.forEach((sound: any, index: number) => {\n      if (sound.kind === \"inst\") {\n        let newSeq: any = {};\n        newSeq[keys.seqKey + index] = buildFromActivity(\n          initState.currentChord,\n          soundSources[index].sounds,\n          soundSources[index].initActivity,\n          soundSources[index].minSoundsInSequence,\n          soundSources[index].maxSoundsInSequence\n        );\n        this.setState({ ...newSeq });\n      }\n      if (sound.kind === \"drum\") {\n        let newSeq: any = {};\n        newSeq[keys.seqKey + index] = buildFromPattern(\n          soundSources[index].initPattern,\n          soundSources[index].patterns,\n          soundSources[index].sounds\n        );\n        this.setState({ ...newSeq });\n      }\n    });\n\n    //setTimeout(()=>this.setState({ loaded: true }), 1000)\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.handleResize);\n  }\n\n  render() {\n    return (\n      <div>\n        {!this.state.mobileUI &&\n          (this.state.showHelp ? (\n            <HelpScreen mobile={false} toggleHelp={this.toggleHelp} />\n          ) : (\n            <div className=\"UIContainer\">\n              <LoadingScreen\n                loaded={this.state.loaded}\n                started={this.state.appStarted}\n                hideOpeningScreen={this.state.hideOpeningScreen}\n                startApp={this.startApp}\n                loadingAnimPoints={this.state.loadingAnimPoints}\n                totalSounds={amountOfSounds}\n                loadedSounds={amountOfSoundsLoaded}\n              />\n\n              <div className=\"UILeft\">\n                <InstContainer\n                  state={this.state}\n                  handleVolumeChange={this.handleVolumeChange}\n                  handleActivityChange={this.handleActivityChange}\n                  handleVolumeClick={this.handleVolumeClick}\n                  handleActivityClick={this.handleActivityClick}\n                  handleDisableToggle={this.handleDisableToggle}\n                  handlePatternChange={this.handlePatternChange}\n                  handleTrackSelect={this.handleTrackSelect}\n                />\n                <ChordContainer\n                  currentChord={this.state.currentChord}\n                  currentBarInProgression={\n                    this.state.masterSeq.currentBarInProgression\n                  }\n                  progression={this.state.masterSeq.progression}\n                  handleChordClick={this.handleChordClick}\n                  showUI={this.state.showChordUI}\n                  handleChordUIToggle={this.handleChordUIToggle}\n                />\n              </div>\n              <div className=\"UIRight\">\n                <DrumContainer\n                  tracks={this.state}\n                  handleVolumeChange={this.handleVolumeChange}\n                  handlePatternChange={this.handlePatternChange}\n                  handleDisableToggle={this.handleDisableToggle}\n                  handleVolumeClick={this.handleVolumeClick}\n                  handlePatternClick={this.handlePatternClick}\n                  showUI={this.state.showDrumUI}\n                  handleTrackSelect={this.handleTrackSelect}\n                />\n                <FXContainer\n                  UIIndex={2}\n                  tracks={this.state}\n                  handleVolumeChange={this.handleVolumeChange}\n                  handleFxUIToggle={this.handleFxUIToggle}\n                  showUI={this.state.showFxUI}\n                />\n                <PlayContainer\n                  bpm={this.state.bpm}\n                  playing={this.state.playing}\n                  handleBpmChange={this.handleBpmChange}\n                  handlePlayingToggle={this.handlePlayingToggle}\n                />\n                {!this.state.showFxUI && (\n                  <FlowButton\n                    drifting={this.state.drifting}\n                    handleDriftToggle={this.handleDriftToggle}\n                  />\n                )}\n                {!this.state.showFxUI && (\n                  <div className=\"helpButton button\" onClick={this.toggleHelp}>\n                    <div className=\"mobileHelp\">?</div>\n                  </div>\n                )}\n              </div>\n            </div>\n          ))}\n        {this.state.mobileUI && (\n          <MobileUI\n            state={this.state}\n            startApp={this.startApp}\n            handleTrackSelect={this.handleTrackSelect}\n            handleVolumeChange={this.handleVolumeChange}\n            handleActivityChange={this.handleActivityChange}\n            handlePatternChange={this.handlePatternChange}\n            handleDisableToggle={this.handleDisableToggle}\n            handlePlayingToggle={this.handlePlayingToggle}\n            handleDriftToggle={this.handleDriftToggle}\n            handleBpmChange={this.handleBpmChange}\n            handleVolumeClick={this.handleVolumeClick}\n            handleActivityClick={this.handleActivityClick}\n            handlePatternClick={this.handlePatternClick}\n            handleChordUIToggle={this.handleChordUIToggle}\n            handleChordClick={this.handleChordClick}\n            toggleHelp={this.toggleHelp}\n          />\n        )}\n      </div>\n    );\n  }\n}\n\nconst InstContainer = React.memo(function InstrumentContainer(props: any) {\n  return (\n    <div className=\"instrumentContainer\">\n      {soundSources.map((track: any, index: number) => {\n        if (track.kind === \"inst\")\n          return (\n            <TrackContainer\n              index={index}\n              key={index}\n              volume={props.state[keys.volKey + index]}\n              range2Value={props.state[keys.actKey + index]}\n              disabled={props.state[keys.disabledKey + index]}\n              range2Min={0}\n              range2Max={100}\n              range2Step={1}\n              kind={track.kind}\n              showTrack={props.state[keys.showTrack + index]}\n              nowPlaying={props.state[keys.nowPlaying + index]}\n              handleVolumeChange={props.handleVolumeChange}\n              handleActivityChange={props.handleActivityChange}\n              handlePatternChange={props.handlePatternChange}\n              handleDisableToggle={props.handleDisableToggle}\n              handleTrackSelect={props.handleTrackSelect}\n              handleVolumeClick={props.handleVolumeClick}\n              handleActivityClick={props.handleActivityClick}\n            />\n          );\n      })}\n    </div>\n  );\n});\n\nconst TrackContainer = React.memo(function TrackUI(props: any) {\n  let colorStr = colors[props.index].toString(16);\n  colorStr = \"#\".concat(colorStr);\n\n  let indicatorClass = \"trackIndicator\";\n  let flexDirection: any;\n\n  if (props.kind === \"inst\") {\n    indicatorClass += \" inst\";\n    flexDirection = \"row\";\n  } else {\n    indicatorClass += \" drum\";\n    flexDirection = \"row-reverse\";\n  }\n  let shadow: string;\n  props.nowPlaying\n    ? (shadow = `0px 0px 15px #${colors[props.index].toString(16)}`)\n    : (shadow = `0px 0px 5px #${colors[props.index].toString(16)}`);\n  if (props.disabled) {\n    indicatorClass += \" disabled\";\n  }\n  return (\n    <div\n      className=\"trackContainer\"\n      style={{ flexDirection: flexDirection }}\n      id={\"track\" + props.index}\n      onMouseOver={() => props.handleTrackSelect(props.index, true)}\n      onMouseOut={() => props.handleTrackSelect(props.index, false)}\n    >\n      <div\n        className={indicatorClass}\n        style={{\n          backgroundColor: colorStr,\n          boxShadow: shadow,\n        }}\n        onClick={() => props.handleDisableToggle(props.disabled, props.index)}\n      ></div>\n      {!props.disabled ? (\n        <div className=\"trackUI\">\n          <div className=\"trackSliderContainer\">\n            <div className=\"trackSlider\">\n              <IconContainer\n                icon1={volumeOff}\n                click={() => props.handleVolumeClick(-10, props.index)}\n              />\n              <ControlledSlider\n                value={props.volume}\n                onChange={props.handleVolumeChange}\n                disabled={props.disabled}\n                index={props.index}\n                min={0}\n                max={100}\n                step={1}\n              />\n              <IconContainer\n                icon1={volumeOn}\n                click={() => props.handleVolumeClick(10, props.index)}\n              />\n            </div>\n            {props.kind === \"inst\" ? (\n              <div className=\"trackSlider\">\n                <IconContainer\n                  icon1={minus}\n                  click={() => props.handleActivityClick(-10, props.index)}\n                />\n                <ControlledSlider\n                  value={props.range2Value}\n                  onChange={props.handleActivityChange}\n                  disabled={props.disabled}\n                  index={props.index}\n                  min={props.range2Min}\n                  max={props.range2Max}\n                  step={props.range2Step}\n                />\n                <IconContainer\n                  icon1={plus}\n                  click={() => props.handleActivityClick(10, props.index)}\n                />\n              </div>\n            ) : (\n              <div className=\"trackSlider\">\n                <IconContainer\n                  icon1={minus}\n                  click={() => props.handlePatternClick(-1, props.index)}\n                />\n                <ControlledSlider\n                  value={props.range2Value}\n                  onChange={props.handlePatternChange}\n                  disabled={props.disabled}\n                  index={props.index}\n                  min={1}\n                  max={soundSources[props.index].patterns.length}\n                  step={props.range2Step}\n                />\n                <IconContainer\n                  icon1={plus}\n                  click={() => props.handlePatternClick(1, props.index)}\n                />\n              </div>\n            )}\n          </div>\n        </div>\n      ) : (\n        \"\"\n      )}\n    </div>\n  );\n});\n\nconst DrumContainer = React.memo(function DrumContainer(props: any) {\n  return (\n    <div className=\"drumContainer\">\n      {soundSources.map((track: any, index: number) => {\n        if (track.kind === \"drum\")\n          return (\n            <TrackContainer\n              index={index}\n              key={index}\n              volume={props.tracks[keys.volKey + index]}\n              range2Value={props.tracks[keys.patKey + index]}\n              disabled={props.tracks[keys.disabledKey + index]}\n              range2Min={0}\n              range2Max={100}\n              range2Step={1}\n              kind={track.kind}\n              showTrack={props.tracks[keys.showTrack + index]}\n              nowPlaying={props.tracks[keys.nowPlaying + index]}\n              handleVolumeChange={props.handleVolumeChange}\n              handleActivityChange={props.handleActivityChange}\n              handlePatternChange={props.handlePatternChange}\n              handleDisableToggle={props.handleDisableToggle}\n              handleTrackSelect={props.handleTrackSelect}\n              handleVolumeClick={props.handleVolumeClick}\n              handlePatternClick={props.handlePatternClick}\n            />\n          );\n      })}\n    </div>\n  );\n});\n\nconst PlayContainer = React.memo(function PlayContainer(props: any) {\n  let playIcon: string;\n  props.playing ? (playIcon = pause) : (playIcon = play);\n  return (\n    <div className=\"playContainer\">\n      <div className=\"bpmslider\">\n        <img className=\"speedIcon\" src={turtle} />\n        <ControlledSlider\n          vertical={true}\n          index={0}\n          value={props.bpm}\n          onChange={props.handleBpmChange}\n          min={minBpm}\n          max={maxBpm}\n        />\n        <img className=\"speedIcon\" src={rabbit} />\n      </div>\n      <div className={\"buttonContainer\"}>\n        <div\n          className=\"button\"\n          onClick={props.handlePlayingToggle}\n          style={{ backgroundImage: \"url(\" + playIcon + \")\" }}\n        ></div>\n      </div>\n    </div>\n  );\n});\n\nconst FlowButton = React.memo(function FlowButton(props: any) {\n  let selectClass = \"\";\n  if (props.drifting) {\n    selectClass = \" flash\";\n  }\n  return (\n    <div\n      onClick={props.handleDriftToggle}\n      className={\"driftButton\" + selectClass}\n      id=\"driftButton\"\n    >\n      {props.drifting ? \"EVOLVING\" : \"EVOLVE\"}\n    </div>\n  );\n});\n\nconst FXContainer = React.memo(function FXContainer(props: any) {\n  let fxIndex = -1;\n  return (\n    <div className=\"fxContainer\">\n      {props.showUI ? (\n        <div className=\"fxUI trackSliders\">\n          {soundSources.map((track: any, index: number) => {\n            if (track.kind === \"fx\") {\n              fxIndex++;\n              return (\n                <FXUI\n                  index={index}\n                  fxIndex={fxIndex}\n                  volume={props.tracks[keys.volKey + index]}\n                  disabled={props.tracks[keys.disabledKey + index]}\n                  key={index}\n                  handleVolumeChange={props.handleVolumeChange}\n                  handleDriftToggle={props.handleDriftToggle}\n                  handleDisableToggle={props.handleDisableToggle}\n                  label={soundSources[index].name}\n                />\n              );\n            }\n          })}\n          <div className=\"closeButton\" onClick={props.handleFxUIToggle}>\n            close\n          </div>\n        </div>\n      ) : (\n        <div className=\"fxIndicator\" onClick={props.handleFxUIToggle}>\n          FX\n        </div>\n      )}\n    </div>\n  );\n});\n\nconst FXUI = React.memo(function FXUI(props: any) {\n  return (\n    <div className=\"fxSlider\">\n      <div className=\"fxLabel\">{props.label}</div>\n      <div className=\"\">\n        <ControlledSlider\n          value={props.volume}\n          onChange={props.handleVolumeChange}\n          disabled={props.disabled}\n          index={props.index}\n          min={0}\n          max={100}\n          step={1}\n        />\n      </div>\n      <IconContainer icon1={fxIcons[props.fxIndex]} />\n    </div>\n  );\n});\n\nexport function IconContainer(props: any) {\n  return (\n    <div className=\"iconContainer\" onClick={props.click}>\n      <img className=\"icon\" src={props.icon1}></img>\n    </div>\n  );\n}\n\nexport function ControlledSlider(props: any) {\n  function handleChange(event: any) {\n    props.onChange(event.target.value, props.index);\n  }\n  let verticalClass = \"\";\n  if (props.vertical) {\n    verticalClass = \" vertical\";\n  }\n  let disabled: string;\n  props.disabled ? (disabled = \"disabled\") : (disabled = \"\");\n  return (\n    <input\n      className={\"slider \" + disabled + verticalClass}\n      type=\"range\"\n      value={props.value}\n      onChange={handleChange}\n      disabled={props.disabled}\n      min={props.min}\n      max={props.max}\n      step={props.step}\n    ></input>\n  );\n}\n\nfunction initializeState() {\n  initState.bpm = 90;\n  initState.playing = true;\n  initState.drifting = false;\n\n  initState.hq = false;\n\n  initState.showChordUI = false;\n  initState.showFxUI = false;\n  initState.showHelp = false;\n\n  initState.appStarted = false;\n  initState.loaded = false;\n  initState.hideOpeningScreen = false;\n  initState.loadingAnimPoints = [];\n\n  initState.trackSelected = [];\n  initState.mobileUI = window.innerWidth < mobile ? true : false;\n\n  initState.masterSeq = {\n    currentSequencePos: 0,\n    lastPlayTime: performance.now(),\n    barsPlayed: 0,\n    FXTimer: -FXLength,\n    newDrumSeq: randomArrEntry(drumChangeOptions),\n    newChord: randomArrEntry(chordChangeOptions),\n    tempoChangeTimer: randomArrEntry(tempoChangeOptions),\n    currentBarInProgression: 0,\n    progression: [5, 5, 4, 3],\n  };\n\n  initState.currentChord = chords[initState.masterSeq.progression[0]].value;\n\n  soundSources.forEach((track: any, index: number) => {\n    initState.trackSelected.push(false);\n    switch (track.kind) {\n      case \"inst\":\n        initState[keys.volKey + index] = soundSources[index].initVolume;\n        initState[keys.actKey + index] = soundSources[index].initActivity;\n        initState[keys.volDriftKey + index] = 0;\n        initState[keys.actDriftKey + index] = 0;\n        initState[keys.disabledKey + index] = soundSources[index].initDisabled;\n        initState[keys.showTrack + index] = false;\n        initState[keys.nowPlaying + index] = false;\n        break;\n\n      case \"drum\":\n        initState[keys.volKey + index] = soundSources[index].initVolume;\n        initState[keys.volDriftKey + index] = 0;\n        initState[keys.disabledKey + index] = soundSources[index].initDisabled;\n        initState[keys.patKey + index] = soundSources[index].initPattern + 1;\n        initState[keys.nowPlaying + index] = false;\n        break;\n\n      case \"fx\":\n        initState[keys.volKey + index] = soundSources[index].initVolume;\n        initState[keys.volDriftKey + index] = 0;\n        initState[keys.disabledKey + index] = soundSources[index].initDisabled;\n        break;\n    }\n  });\n}\n\nexport function randomArrEntry(arr: any) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nfunction playSequencers(state: any) {\n  let whosPlaying: any = {};\n  soundSources.forEach((track: any, index: any) => {\n    whosPlaying[keys.nowPlaying + index] = false;\n    if (!state[keys.disabledKey + index]) {\n      if (track.kind === \"inst\" || track.kind === \"drum\") {\n        let soundIndex =\n          state[keys.seqKey + index][state.masterSeq.currentSequencePos];\n        if (!isNaN(soundIndex)) {\n          soundSources[index].sounds[soundIndex].howl.play();\n          whosPlaying[keys.nowPlaying + index] = true;\n          ripple(\n            index,\n            state[keys.volKey + index],\n            state.masterSeq.currentSequencePos\n          );\n        }\n      }\n    }\n  });\n  return whosPlaying;\n}\n\nexport default App;\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/drift.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundplayer.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/soundsources.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/visuals.ts",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/chordcontainer.tsx",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/loadingscreen.tsx",[],"/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/mobileui.tsx",["53","54","55","56"],"import {\n  keys,\n  amountOfSounds,\n  amountOfSoundsLoaded,\n  ControlledSlider,\n  IconContainer,\n  minBpm,\n  maxBpm,\n} from \"./App\";\nimport React, { useState, useEffect } from \"react\";\nimport { soundSources } from \"./soundsources\";\nimport { colors } from \"./visuals\";\nimport LoadingScreen from \"./loadingscreen\";\nimport HelpScreen from \"./helpscreen\";\n\nimport ChordContainer from \"./chordcontainer\";\n\nimport minus from \"./img/minus.svg\";\nimport plus from \"./img/plus.svg\";\nimport volumeOn from \"./img/volumeon.svg\";\nimport volumeOff from \"./img/volumeoff.svg\";\nimport play from \"./img/play.svg\";\nimport pause from \"./img/pause.svg\";\nimport turtle from \"./img/turtle.svg\";\nimport rabbit from \"./img/rabbit.svg\";\n\nimport \"./mobile.css\";\n\nexport const MobileUI = ({\n  state,\n  startApp,\n  handleTrackSelect,\n  handleVolumeChange,\n  handleActivityChange,\n  handlePatternChange,\n  handleDisableToggle,\n  handlePlayingToggle,\n  handleDriftToggle,\n  handleBpmChange,\n  handleVolumeClick,\n  handleActivityClick,\n  handlePatternClick,\n  handleChordUIToggle,\n  handleChordClick,\n  toggleHelp,\n}: any) => {\n  const [trackOpen, setTrackOpen] = useState(false);\n\n  const [openIndex, setOpenIndex] = useState(0);\n\n  const handleTrackClick = (index: number, open: boolean) => {\n    setTrackOpen(open);\n    setOpenIndex(index);\n    handleTrackSelect(index, open);\n  };\n\n  return (\n    <div className=\"mobileUIContainer\">\n      <LoadingScreen\n        loaded={state.loaded}\n        started={state.appStarted}\n        hideOpeningScreen={state.hideOpeningScreen}\n        startApp={startApp}\n        loadingAnimPoints={state.loadingAnimPoints}\n        totalSounds={amountOfSounds}\n        loadedSounds={amountOfSoundsLoaded}\n      />\n      {!trackOpen &&\n        (state.showHelp ? (\n          <HelpScreen mobile={true} toggleHelp={toggleHelp} />\n        ) : state.showChordUI ? (\n          <ChordContainer\n            showUI={true}\n            progression={state.masterSeq.progression}\n            handleChordUIToggle={handleChordUIToggle}\n            handleChordClick={handleChordClick}\n            currentBarInProgression={state.masterSeq.currentBarInProgression}\n            mobile={true}\n          />\n        ) : (\n          <div className=\"mobileUIContainerBase\">\n            <div className=\"mobileTrackContainer\">\n              {soundSources.map((track: any, index: number) => {\n                if (track.kind === \"drum\" || track.kind === \"inst\") {\n                  return (\n                    <MobileTrackButton\n                      handleTrackClick={handleTrackClick}\n                      key={index}\n                      index={index}\n                      nowPlaying={state[keys.nowPlaying + index]}\n                      disabled={state[keys.disabledKey + index]}\n                    />\n                  );\n                }\n              })}\n            </div>\n            <MobileSideButtons\n              handlePlayingToggle={handlePlayingToggle}\n              handleDriftToggle={handleDriftToggle}\n              handleChordUIToggle={handleChordUIToggle}\n              toggleHelp={toggleHelp}\n              playing={state.playing}\n              drifting={state.drifting}\n            />\n          </div>\n        ))}\n      {trackOpen && (\n        <MobileTrackEditor\n          state={state}\n          openIndex={openIndex}\n          handleTrackClick={handleTrackClick}\n          handleVolumeChange={handleVolumeChange}\n          handlePatternChange={handlePatternChange}\n          handleActivityChange={handleActivityChange}\n          handleDisableToggle={handleDisableToggle}\n          handleVolumeClick={handleVolumeClick}\n          handleActivityClick={handleActivityClick}\n          handlePatternClick={handlePatternClick}\n        />\n      )}\n      {!state.showChordUI && (\n        <div className=\"mobileUIContainerBottom\">\n          <div className=\"trackSlider\">\n            <img className=\"speedIcon\" src={turtle} />\n            <ControlledSlider\n              vertical={false}\n              index={0}\n              value={state.bpm}\n              onChange={handleBpmChange}\n              min={minBpm}\n              max={maxBpm}\n            />\n            <img className=\"speedIcon\" src={rabbit} />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nconst MobileSideButtons = React.memo(function MobileSideButtons({\n  handlePlayingToggle,\n  handleDriftToggle,\n  handleChordUIToggle,\n  toggleHelp,\n  playing,\n  drifting,\n}: any) {\n  let playIcon: string;\n  playing ? (playIcon = pause) : (playIcon = play);\n  return (\n    <div className={\"mobileButtonContainer\"}>\n      <div\n        className=\"mobileButton\"\n        onClick={handlePlayingToggle}\n        style={{ backgroundImage: \"url('\" + playIcon + \"')\" }}\n      ></div>\n      <div className=\"mobileButton \" onClick={toggleHelp}>\n        <div className=\"mobileHelp\">?</div>\n      </div>\n      <div className=\"mobileButton \" onClick={handleChordUIToggle}>\n        <div\n          className={drifting ? \"mobileHelp flash\" : \"mobileHelp\"}\n          style={{ fontSize: \"1rem\" }}\n        >\n          CHORDS\n        </div>\n      </div>\n      <div\n        className=\"mobileButton mobileDriftButton\"\n        onClick={handleDriftToggle}\n      >\n        <div\n          className={drifting ? \"mobileHelp flash\" : \"mobileHelp\"}\n          style={{ fontSize: \"1rem\" }}\n        >\n          {drifting ? \"EVOLVING\" : \"EVOLVE\"}\n        </div>\n      </div>\n    </div>\n  );\n});\n\nconst MobileTrackButton = React.memo(function MobileTrackButton({\n  handleTrackClick,\n  index,\n  nowPlaying,\n  disabled,\n}: any) {\n  let colorStr = colors[index].toString(16);\n  colorStr = \"#\".concat(colorStr);\n\n  let shadow: string;\n  nowPlaying\n    ? (shadow = `0px 0px 15px #${colors[index].toString(16)}`)\n    : (shadow = `0px 0px 5px #${colors[index].toString(16)}`);\n\n  let indicatorClass = \"mobileTrackIndicator\";\n\n  if (disabled) {\n    indicatorClass += \" disabled\";\n  }\n\n  return (\n    <div className=\"mobileTrack\">\n      <div\n        className={indicatorClass}\n        style={{\n          backgroundColor: colorStr,\n          boxShadow: shadow,\n        }}\n        onClick={() => handleTrackClick(index, true)}\n      ></div>\n    </div>\n  );\n});\n\nconst MobileTrackEditor = React.memo(function MobileTrackEditor({\n  openIndex,\n  nowPlaying,\n  state,\n  handleTrackClick,\n  handleVolumeChange,\n  handleActivityChange,\n  handlePatternChange,\n  handleDisableToggle,\n  handleVolumeClick,\n  handleActivityClick,\n  handlePatternClick,\n}: any) {\n  let colorStr = colors[openIndex].toString(16);\n  colorStr = \"#\".concat(colorStr);\n\n  let shadow: string;\n  nowPlaying\n    ? (shadow = `0px 0px 15px #${colors[openIndex].toString(16)}`)\n    : (shadow = `0px 0px 5px #${colors[openIndex].toString(16)}`);\n\n  let indicatorClass = \"mobileTrackIndicator single\";\n\n  if (state[keys.disabledKey + openIndex]) {\n    indicatorClass += \" disabled\";\n  }\n\n  return (\n    <div className=\"mobileTrackEditor\">\n      <div className=\"mobileTrackEditorTop\">\n        <div className=\"mobileTrackIndicatorEditor\">\n          <div\n            className={indicatorClass}\n            style={{\n              backgroundColor: colorStr,\n              boxShadow: shadow,\n            }}\n            onClick={() =>\n              handleDisableToggle(\n                state[keys.disabledKey + openIndex],\n                openIndex\n              )\n            }\n          ></div>\n        </div>\n        <div className=\"trackUI\">\n          <div className=\"trackSliderContainer\">\n            <div className=\"trackSlider\">\n              <IconContainer\n                icon1={volumeOff}\n                click={() => handleVolumeClick(-10, openIndex)}\n              />\n              <ControlledSlider\n                value={state[keys.volKey + openIndex]}\n                onChange={handleVolumeChange}\n                disabled={state[keys.disabledKey + openIndex]}\n                index={openIndex}\n                min={0}\n                max={100}\n                step={1}\n              />\n              <IconContainer\n                icon1={volumeOn}\n                click={() => handleVolumeClick(10, openIndex)}\n              />\n            </div>\n            {soundSources[openIndex].kind === \"inst\" ? (\n              <div className=\"trackSlider\">\n                <IconContainer\n                  icon1={minus}\n                  click={() => handleActivityClick(-10, openIndex)}\n                />\n                <ControlledSlider\n                  value={state[keys.actKey + openIndex]}\n                  onChange={handleActivityChange}\n                  disabled={state[keys.disabledKey + openIndex]}\n                  index={openIndex}\n                  min={0}\n                  max={100}\n                  step={1}\n                />\n                <IconContainer\n                  icon1={plus}\n                  click={() => handleActivityClick(10, openIndex)}\n                />\n              </div>\n            ) : (\n              <div className=\"trackSlider\">\n                <IconContainer\n                  icon1={minus}\n                  click={() => handlePatternClick(-1, openIndex)}\n                />\n                <ControlledSlider\n                  value={state[keys.patKey + openIndex]}\n                  onChange={handlePatternChange}\n                  disabled={state[keys.disabledKey + openIndex]}\n                  index={openIndex}\n                  min={1}\n                  max={soundSources[openIndex].patterns.length}\n                  step={1}\n                />\n                <IconContainer\n                  icon1={plus}\n                  click={() => handlePatternClick(1, openIndex)}\n                />\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n      <div className=\"mobileEditorButtonContainer\">\n        <div\n          className=\"mobileEditorButton\"\n          onClick={() =>\n            handleDisableToggle(state[keys.disabledKey + openIndex], openIndex)\n          }\n        >\n          <u className={state[keys.disabledKey + openIndex] ? \"flash\" : \"\"}>\n            {state[keys.disabledKey + openIndex] ? \"TURN ON\" : \"TURN OFF\"}\n          </u>\n        </div>\n        <div\n          className=\"mobileEditorButton\"\n          onClick={() => handleTrackClick(openIndex, false)}\n        >\n          <u>CLOSE</u>\n        </div>\n      </div>\n    </div>\n  );\n});\n","/Users/Ruben/Desktop/Coding/projects/ambientmusic/src/helpscreen.tsx",[],{"ruleId":"57","replacedBy":"58"},{"ruleId":"59","replacedBy":"60"},{"ruleId":"61","severity":1,"message":"62","line":652,"column":53,"nodeType":"63","messageId":"64","endLine":652,"endColumn":55},{"ruleId":"61","severity":1,"message":"62","line":793,"column":53,"nodeType":"63","messageId":"64","endLine":793,"endColumn":55},{"ruleId":"65","severity":1,"message":"66","line":828,"column":9,"nodeType":"67","endLine":828,"endColumn":51},{"ruleId":"65","severity":1,"message":"66","line":837,"column":9,"nodeType":"67","endLine":837,"endColumn":51},{"ruleId":"61","severity":1,"message":"62","line":872,"column":57,"nodeType":"63","messageId":"64","endLine":872,"endColumn":59},{"ruleId":"65","severity":1,"message":"66","line":926,"column":7,"nodeType":"67","endLine":926,"endColumn":47},{"ruleId":"68","severity":1,"message":"69","line":10,"column":27,"nodeType":"70","messageId":"71","endLine":10,"endColumn":36},{"ruleId":"61","severity":1,"message":"62","line":83,"column":61,"nodeType":"63","messageId":"64","endLine":83,"endColumn":63},{"ruleId":"65","severity":1,"message":"66","line":124,"column":13,"nodeType":"67","endLine":124,"endColumn":55},{"ruleId":"65","severity":1,"message":"66","line":133,"column":13,"nodeType":"67","endLine":133,"endColumn":55},"no-native-reassign",["72"],"no-negated-in-lhs",["73"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","@typescript-eslint/no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]